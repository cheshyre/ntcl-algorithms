! Auto-generated. DO NOT MODIFY!
module easy_tensor_contraction_interface
    use, intrinsic :: iso_fortran_env, only : &
            real64, &
            real32
    use :: util_api, only : &
            string, &
            dictionary
    use :: tensor_api, only : &
            tensor, &
            scalar, &
            allocate_and_copy_tensor, &
            secure_fortran_pointer_from_tensor, &
            release_pointer_from_remote_tensor
    use :: tensor_contraction_api, only : &
            tensor_contraction, &
            tensor_contraction_factory

    implicit none
    private

    public :: contract

    interface contract
        module procedure contract_rank0_rank0_rank0_for_complex128
        module procedure contract_rank0_rank0_rank1_for_complex128
        module procedure contract_rank0_rank0_rank2_for_complex128
        module procedure contract_rank0_rank0_rank3_for_complex128
        module procedure contract_rank0_rank0_rank4_for_complex128
        module procedure contract_rank0_rank0_rank5_for_complex128
        module procedure contract_rank0_rank1_rank0_for_complex128
        module procedure contract_rank0_rank1_rank1_for_complex128
        module procedure contract_rank0_rank1_rank2_for_complex128
        module procedure contract_rank0_rank1_rank3_for_complex128
        module procedure contract_rank0_rank1_rank4_for_complex128
        module procedure contract_rank0_rank1_rank5_for_complex128
        module procedure contract_rank0_rank2_rank0_for_complex128
        module procedure contract_rank0_rank2_rank1_for_complex128
        module procedure contract_rank0_rank2_rank2_for_complex128
        module procedure contract_rank0_rank2_rank3_for_complex128
        module procedure contract_rank0_rank2_rank4_for_complex128
        module procedure contract_rank0_rank2_rank5_for_complex128
        module procedure contract_rank0_rank3_rank0_for_complex128
        module procedure contract_rank0_rank3_rank1_for_complex128
        module procedure contract_rank0_rank3_rank2_for_complex128
        module procedure contract_rank0_rank3_rank3_for_complex128
        module procedure contract_rank0_rank3_rank4_for_complex128
        module procedure contract_rank0_rank3_rank5_for_complex128
        module procedure contract_rank0_rank4_rank0_for_complex128
        module procedure contract_rank0_rank4_rank1_for_complex128
        module procedure contract_rank0_rank4_rank2_for_complex128
        module procedure contract_rank0_rank4_rank3_for_complex128
        module procedure contract_rank0_rank4_rank4_for_complex128
        module procedure contract_rank0_rank4_rank5_for_complex128
        module procedure contract_rank0_rank5_rank0_for_complex128
        module procedure contract_rank0_rank5_rank1_for_complex128
        module procedure contract_rank0_rank5_rank2_for_complex128
        module procedure contract_rank0_rank5_rank3_for_complex128
        module procedure contract_rank0_rank5_rank4_for_complex128
        module procedure contract_rank0_rank5_rank5_for_complex128
        module procedure contract_rank1_rank0_rank0_for_complex128
        module procedure contract_rank1_rank0_rank1_for_complex128
        module procedure contract_rank1_rank0_rank2_for_complex128
        module procedure contract_rank1_rank0_rank3_for_complex128
        module procedure contract_rank1_rank0_rank4_for_complex128
        module procedure contract_rank1_rank0_rank5_for_complex128
        module procedure contract_rank1_rank1_rank0_for_complex128
        module procedure contract_rank1_rank1_rank1_for_complex128
        module procedure contract_rank1_rank1_rank2_for_complex128
        module procedure contract_rank1_rank1_rank3_for_complex128
        module procedure contract_rank1_rank1_rank4_for_complex128
        module procedure contract_rank1_rank1_rank5_for_complex128
        module procedure contract_rank1_rank2_rank0_for_complex128
        module procedure contract_rank1_rank2_rank1_for_complex128
        module procedure contract_rank1_rank2_rank2_for_complex128
        module procedure contract_rank1_rank2_rank3_for_complex128
        module procedure contract_rank1_rank2_rank4_for_complex128
        module procedure contract_rank1_rank2_rank5_for_complex128
        module procedure contract_rank1_rank3_rank0_for_complex128
        module procedure contract_rank1_rank3_rank1_for_complex128
        module procedure contract_rank1_rank3_rank2_for_complex128
        module procedure contract_rank1_rank3_rank3_for_complex128
        module procedure contract_rank1_rank3_rank4_for_complex128
        module procedure contract_rank1_rank3_rank5_for_complex128
        module procedure contract_rank1_rank4_rank0_for_complex128
        module procedure contract_rank1_rank4_rank1_for_complex128
        module procedure contract_rank1_rank4_rank2_for_complex128
        module procedure contract_rank1_rank4_rank3_for_complex128
        module procedure contract_rank1_rank4_rank4_for_complex128
        module procedure contract_rank1_rank4_rank5_for_complex128
        module procedure contract_rank1_rank5_rank0_for_complex128
        module procedure contract_rank1_rank5_rank1_for_complex128
        module procedure contract_rank1_rank5_rank2_for_complex128
        module procedure contract_rank1_rank5_rank3_for_complex128
        module procedure contract_rank1_rank5_rank4_for_complex128
        module procedure contract_rank1_rank5_rank5_for_complex128
        module procedure contract_rank2_rank0_rank0_for_complex128
        module procedure contract_rank2_rank0_rank1_for_complex128
        module procedure contract_rank2_rank0_rank2_for_complex128
        module procedure contract_rank2_rank0_rank3_for_complex128
        module procedure contract_rank2_rank0_rank4_for_complex128
        module procedure contract_rank2_rank0_rank5_for_complex128
        module procedure contract_rank2_rank1_rank0_for_complex128
        module procedure contract_rank2_rank1_rank1_for_complex128
        module procedure contract_rank2_rank1_rank2_for_complex128
        module procedure contract_rank2_rank1_rank3_for_complex128
        module procedure contract_rank2_rank1_rank4_for_complex128
        module procedure contract_rank2_rank1_rank5_for_complex128
        module procedure contract_rank2_rank2_rank0_for_complex128
        module procedure contract_rank2_rank2_rank1_for_complex128
        module procedure contract_rank2_rank2_rank2_for_complex128
        module procedure contract_rank2_rank2_rank3_for_complex128
        module procedure contract_rank2_rank2_rank4_for_complex128
        module procedure contract_rank2_rank2_rank5_for_complex128
        module procedure contract_rank2_rank3_rank0_for_complex128
        module procedure contract_rank2_rank3_rank1_for_complex128
        module procedure contract_rank2_rank3_rank2_for_complex128
        module procedure contract_rank2_rank3_rank3_for_complex128
        module procedure contract_rank2_rank3_rank4_for_complex128
        module procedure contract_rank2_rank3_rank5_for_complex128
        module procedure contract_rank2_rank4_rank0_for_complex128
        module procedure contract_rank2_rank4_rank1_for_complex128
        module procedure contract_rank2_rank4_rank2_for_complex128
        module procedure contract_rank2_rank4_rank3_for_complex128
        module procedure contract_rank2_rank4_rank4_for_complex128
        module procedure contract_rank2_rank4_rank5_for_complex128
        module procedure contract_rank2_rank5_rank0_for_complex128
        module procedure contract_rank2_rank5_rank1_for_complex128
        module procedure contract_rank2_rank5_rank2_for_complex128
        module procedure contract_rank2_rank5_rank3_for_complex128
        module procedure contract_rank2_rank5_rank4_for_complex128
        module procedure contract_rank2_rank5_rank5_for_complex128
        module procedure contract_rank3_rank0_rank0_for_complex128
        module procedure contract_rank3_rank0_rank1_for_complex128
        module procedure contract_rank3_rank0_rank2_for_complex128
        module procedure contract_rank3_rank0_rank3_for_complex128
        module procedure contract_rank3_rank0_rank4_for_complex128
        module procedure contract_rank3_rank0_rank5_for_complex128
        module procedure contract_rank3_rank1_rank0_for_complex128
        module procedure contract_rank3_rank1_rank1_for_complex128
        module procedure contract_rank3_rank1_rank2_for_complex128
        module procedure contract_rank3_rank1_rank3_for_complex128
        module procedure contract_rank3_rank1_rank4_for_complex128
        module procedure contract_rank3_rank1_rank5_for_complex128
        module procedure contract_rank3_rank2_rank0_for_complex128
        module procedure contract_rank3_rank2_rank1_for_complex128
        module procedure contract_rank3_rank2_rank2_for_complex128
        module procedure contract_rank3_rank2_rank3_for_complex128
        module procedure contract_rank3_rank2_rank4_for_complex128
        module procedure contract_rank3_rank2_rank5_for_complex128
        module procedure contract_rank3_rank3_rank0_for_complex128
        module procedure contract_rank3_rank3_rank1_for_complex128
        module procedure contract_rank3_rank3_rank2_for_complex128
        module procedure contract_rank3_rank3_rank3_for_complex128
        module procedure contract_rank3_rank3_rank4_for_complex128
        module procedure contract_rank3_rank3_rank5_for_complex128
        module procedure contract_rank3_rank4_rank0_for_complex128
        module procedure contract_rank3_rank4_rank1_for_complex128
        module procedure contract_rank3_rank4_rank2_for_complex128
        module procedure contract_rank3_rank4_rank3_for_complex128
        module procedure contract_rank3_rank4_rank4_for_complex128
        module procedure contract_rank3_rank4_rank5_for_complex128
        module procedure contract_rank3_rank5_rank0_for_complex128
        module procedure contract_rank3_rank5_rank1_for_complex128
        module procedure contract_rank3_rank5_rank2_for_complex128
        module procedure contract_rank3_rank5_rank3_for_complex128
        module procedure contract_rank3_rank5_rank4_for_complex128
        module procedure contract_rank3_rank5_rank5_for_complex128
        module procedure contract_rank4_rank0_rank0_for_complex128
        module procedure contract_rank4_rank0_rank1_for_complex128
        module procedure contract_rank4_rank0_rank2_for_complex128
        module procedure contract_rank4_rank0_rank3_for_complex128
        module procedure contract_rank4_rank0_rank4_for_complex128
        module procedure contract_rank4_rank0_rank5_for_complex128
        module procedure contract_rank4_rank1_rank0_for_complex128
        module procedure contract_rank4_rank1_rank1_for_complex128
        module procedure contract_rank4_rank1_rank2_for_complex128
        module procedure contract_rank4_rank1_rank3_for_complex128
        module procedure contract_rank4_rank1_rank4_for_complex128
        module procedure contract_rank4_rank1_rank5_for_complex128
        module procedure contract_rank4_rank2_rank0_for_complex128
        module procedure contract_rank4_rank2_rank1_for_complex128
        module procedure contract_rank4_rank2_rank2_for_complex128
        module procedure contract_rank4_rank2_rank3_for_complex128
        module procedure contract_rank4_rank2_rank4_for_complex128
        module procedure contract_rank4_rank2_rank5_for_complex128
        module procedure contract_rank4_rank3_rank0_for_complex128
        module procedure contract_rank4_rank3_rank1_for_complex128
        module procedure contract_rank4_rank3_rank2_for_complex128
        module procedure contract_rank4_rank3_rank3_for_complex128
        module procedure contract_rank4_rank3_rank4_for_complex128
        module procedure contract_rank4_rank3_rank5_for_complex128
        module procedure contract_rank4_rank4_rank0_for_complex128
        module procedure contract_rank4_rank4_rank1_for_complex128
        module procedure contract_rank4_rank4_rank2_for_complex128
        module procedure contract_rank4_rank4_rank3_for_complex128
        module procedure contract_rank4_rank4_rank4_for_complex128
        module procedure contract_rank4_rank4_rank5_for_complex128
        module procedure contract_rank4_rank5_rank0_for_complex128
        module procedure contract_rank4_rank5_rank1_for_complex128
        module procedure contract_rank4_rank5_rank2_for_complex128
        module procedure contract_rank4_rank5_rank3_for_complex128
        module procedure contract_rank4_rank5_rank4_for_complex128
        module procedure contract_rank4_rank5_rank5_for_complex128
        module procedure contract_rank5_rank0_rank0_for_complex128
        module procedure contract_rank5_rank0_rank1_for_complex128
        module procedure contract_rank5_rank0_rank2_for_complex128
        module procedure contract_rank5_rank0_rank3_for_complex128
        module procedure contract_rank5_rank0_rank4_for_complex128
        module procedure contract_rank5_rank0_rank5_for_complex128
        module procedure contract_rank5_rank1_rank0_for_complex128
        module procedure contract_rank5_rank1_rank1_for_complex128
        module procedure contract_rank5_rank1_rank2_for_complex128
        module procedure contract_rank5_rank1_rank3_for_complex128
        module procedure contract_rank5_rank1_rank4_for_complex128
        module procedure contract_rank5_rank1_rank5_for_complex128
        module procedure contract_rank5_rank2_rank0_for_complex128
        module procedure contract_rank5_rank2_rank1_for_complex128
        module procedure contract_rank5_rank2_rank2_for_complex128
        module procedure contract_rank5_rank2_rank3_for_complex128
        module procedure contract_rank5_rank2_rank4_for_complex128
        module procedure contract_rank5_rank2_rank5_for_complex128
        module procedure contract_rank5_rank3_rank0_for_complex128
        module procedure contract_rank5_rank3_rank1_for_complex128
        module procedure contract_rank5_rank3_rank2_for_complex128
        module procedure contract_rank5_rank3_rank3_for_complex128
        module procedure contract_rank5_rank3_rank4_for_complex128
        module procedure contract_rank5_rank3_rank5_for_complex128
        module procedure contract_rank5_rank4_rank0_for_complex128
        module procedure contract_rank5_rank4_rank1_for_complex128
        module procedure contract_rank5_rank4_rank2_for_complex128
        module procedure contract_rank5_rank4_rank3_for_complex128
        module procedure contract_rank5_rank4_rank4_for_complex128
        module procedure contract_rank5_rank4_rank5_for_complex128
        module procedure contract_rank5_rank5_rank0_for_complex128
        module procedure contract_rank5_rank5_rank1_for_complex128
        module procedure contract_rank5_rank5_rank2_for_complex128
        module procedure contract_rank5_rank5_rank3_for_complex128
        module procedure contract_rank5_rank5_rank4_for_complex128
        module procedure contract_rank5_rank5_rank5_for_complex128
        module procedure contract_rank0_rank0_rank0_for_complex64
        module procedure contract_rank0_rank0_rank1_for_complex64
        module procedure contract_rank0_rank0_rank2_for_complex64
        module procedure contract_rank0_rank0_rank3_for_complex64
        module procedure contract_rank0_rank0_rank4_for_complex64
        module procedure contract_rank0_rank0_rank5_for_complex64
        module procedure contract_rank0_rank1_rank0_for_complex64
        module procedure contract_rank0_rank1_rank1_for_complex64
        module procedure contract_rank0_rank1_rank2_for_complex64
        module procedure contract_rank0_rank1_rank3_for_complex64
        module procedure contract_rank0_rank1_rank4_for_complex64
        module procedure contract_rank0_rank1_rank5_for_complex64
        module procedure contract_rank0_rank2_rank0_for_complex64
        module procedure contract_rank0_rank2_rank1_for_complex64
        module procedure contract_rank0_rank2_rank2_for_complex64
        module procedure contract_rank0_rank2_rank3_for_complex64
        module procedure contract_rank0_rank2_rank4_for_complex64
        module procedure contract_rank0_rank2_rank5_for_complex64
        module procedure contract_rank0_rank3_rank0_for_complex64
        module procedure contract_rank0_rank3_rank1_for_complex64
        module procedure contract_rank0_rank3_rank2_for_complex64
        module procedure contract_rank0_rank3_rank3_for_complex64
        module procedure contract_rank0_rank3_rank4_for_complex64
        module procedure contract_rank0_rank3_rank5_for_complex64
        module procedure contract_rank0_rank4_rank0_for_complex64
        module procedure contract_rank0_rank4_rank1_for_complex64
        module procedure contract_rank0_rank4_rank2_for_complex64
        module procedure contract_rank0_rank4_rank3_for_complex64
        module procedure contract_rank0_rank4_rank4_for_complex64
        module procedure contract_rank0_rank4_rank5_for_complex64
        module procedure contract_rank0_rank5_rank0_for_complex64
        module procedure contract_rank0_rank5_rank1_for_complex64
        module procedure contract_rank0_rank5_rank2_for_complex64
        module procedure contract_rank0_rank5_rank3_for_complex64
        module procedure contract_rank0_rank5_rank4_for_complex64
        module procedure contract_rank0_rank5_rank5_for_complex64
        module procedure contract_rank1_rank0_rank0_for_complex64
        module procedure contract_rank1_rank0_rank1_for_complex64
        module procedure contract_rank1_rank0_rank2_for_complex64
        module procedure contract_rank1_rank0_rank3_for_complex64
        module procedure contract_rank1_rank0_rank4_for_complex64
        module procedure contract_rank1_rank0_rank5_for_complex64
        module procedure contract_rank1_rank1_rank0_for_complex64
        module procedure contract_rank1_rank1_rank1_for_complex64
        module procedure contract_rank1_rank1_rank2_for_complex64
        module procedure contract_rank1_rank1_rank3_for_complex64
        module procedure contract_rank1_rank1_rank4_for_complex64
        module procedure contract_rank1_rank1_rank5_for_complex64
        module procedure contract_rank1_rank2_rank0_for_complex64
        module procedure contract_rank1_rank2_rank1_for_complex64
        module procedure contract_rank1_rank2_rank2_for_complex64
        module procedure contract_rank1_rank2_rank3_for_complex64
        module procedure contract_rank1_rank2_rank4_for_complex64
        module procedure contract_rank1_rank2_rank5_for_complex64
        module procedure contract_rank1_rank3_rank0_for_complex64
        module procedure contract_rank1_rank3_rank1_for_complex64
        module procedure contract_rank1_rank3_rank2_for_complex64
        module procedure contract_rank1_rank3_rank3_for_complex64
        module procedure contract_rank1_rank3_rank4_for_complex64
        module procedure contract_rank1_rank3_rank5_for_complex64
        module procedure contract_rank1_rank4_rank0_for_complex64
        module procedure contract_rank1_rank4_rank1_for_complex64
        module procedure contract_rank1_rank4_rank2_for_complex64
        module procedure contract_rank1_rank4_rank3_for_complex64
        module procedure contract_rank1_rank4_rank4_for_complex64
        module procedure contract_rank1_rank4_rank5_for_complex64
        module procedure contract_rank1_rank5_rank0_for_complex64
        module procedure contract_rank1_rank5_rank1_for_complex64
        module procedure contract_rank1_rank5_rank2_for_complex64
        module procedure contract_rank1_rank5_rank3_for_complex64
        module procedure contract_rank1_rank5_rank4_for_complex64
        module procedure contract_rank1_rank5_rank5_for_complex64
        module procedure contract_rank2_rank0_rank0_for_complex64
        module procedure contract_rank2_rank0_rank1_for_complex64
        module procedure contract_rank2_rank0_rank2_for_complex64
        module procedure contract_rank2_rank0_rank3_for_complex64
        module procedure contract_rank2_rank0_rank4_for_complex64
        module procedure contract_rank2_rank0_rank5_for_complex64
        module procedure contract_rank2_rank1_rank0_for_complex64
        module procedure contract_rank2_rank1_rank1_for_complex64
        module procedure contract_rank2_rank1_rank2_for_complex64
        module procedure contract_rank2_rank1_rank3_for_complex64
        module procedure contract_rank2_rank1_rank4_for_complex64
        module procedure contract_rank2_rank1_rank5_for_complex64
        module procedure contract_rank2_rank2_rank0_for_complex64
        module procedure contract_rank2_rank2_rank1_for_complex64
        module procedure contract_rank2_rank2_rank2_for_complex64
        module procedure contract_rank2_rank2_rank3_for_complex64
        module procedure contract_rank2_rank2_rank4_for_complex64
        module procedure contract_rank2_rank2_rank5_for_complex64
        module procedure contract_rank2_rank3_rank0_for_complex64
        module procedure contract_rank2_rank3_rank1_for_complex64
        module procedure contract_rank2_rank3_rank2_for_complex64
        module procedure contract_rank2_rank3_rank3_for_complex64
        module procedure contract_rank2_rank3_rank4_for_complex64
        module procedure contract_rank2_rank3_rank5_for_complex64
        module procedure contract_rank2_rank4_rank0_for_complex64
        module procedure contract_rank2_rank4_rank1_for_complex64
        module procedure contract_rank2_rank4_rank2_for_complex64
        module procedure contract_rank2_rank4_rank3_for_complex64
        module procedure contract_rank2_rank4_rank4_for_complex64
        module procedure contract_rank2_rank4_rank5_for_complex64
        module procedure contract_rank2_rank5_rank0_for_complex64
        module procedure contract_rank2_rank5_rank1_for_complex64
        module procedure contract_rank2_rank5_rank2_for_complex64
        module procedure contract_rank2_rank5_rank3_for_complex64
        module procedure contract_rank2_rank5_rank4_for_complex64
        module procedure contract_rank2_rank5_rank5_for_complex64
        module procedure contract_rank3_rank0_rank0_for_complex64
        module procedure contract_rank3_rank0_rank1_for_complex64
        module procedure contract_rank3_rank0_rank2_for_complex64
        module procedure contract_rank3_rank0_rank3_for_complex64
        module procedure contract_rank3_rank0_rank4_for_complex64
        module procedure contract_rank3_rank0_rank5_for_complex64
        module procedure contract_rank3_rank1_rank0_for_complex64
        module procedure contract_rank3_rank1_rank1_for_complex64
        module procedure contract_rank3_rank1_rank2_for_complex64
        module procedure contract_rank3_rank1_rank3_for_complex64
        module procedure contract_rank3_rank1_rank4_for_complex64
        module procedure contract_rank3_rank1_rank5_for_complex64
        module procedure contract_rank3_rank2_rank0_for_complex64
        module procedure contract_rank3_rank2_rank1_for_complex64
        module procedure contract_rank3_rank2_rank2_for_complex64
        module procedure contract_rank3_rank2_rank3_for_complex64
        module procedure contract_rank3_rank2_rank4_for_complex64
        module procedure contract_rank3_rank2_rank5_for_complex64
        module procedure contract_rank3_rank3_rank0_for_complex64
        module procedure contract_rank3_rank3_rank1_for_complex64
        module procedure contract_rank3_rank3_rank2_for_complex64
        module procedure contract_rank3_rank3_rank3_for_complex64
        module procedure contract_rank3_rank3_rank4_for_complex64
        module procedure contract_rank3_rank3_rank5_for_complex64
        module procedure contract_rank3_rank4_rank0_for_complex64
        module procedure contract_rank3_rank4_rank1_for_complex64
        module procedure contract_rank3_rank4_rank2_for_complex64
        module procedure contract_rank3_rank4_rank3_for_complex64
        module procedure contract_rank3_rank4_rank4_for_complex64
        module procedure contract_rank3_rank4_rank5_for_complex64
        module procedure contract_rank3_rank5_rank0_for_complex64
        module procedure contract_rank3_rank5_rank1_for_complex64
        module procedure contract_rank3_rank5_rank2_for_complex64
        module procedure contract_rank3_rank5_rank3_for_complex64
        module procedure contract_rank3_rank5_rank4_for_complex64
        module procedure contract_rank3_rank5_rank5_for_complex64
        module procedure contract_rank4_rank0_rank0_for_complex64
        module procedure contract_rank4_rank0_rank1_for_complex64
        module procedure contract_rank4_rank0_rank2_for_complex64
        module procedure contract_rank4_rank0_rank3_for_complex64
        module procedure contract_rank4_rank0_rank4_for_complex64
        module procedure contract_rank4_rank0_rank5_for_complex64
        module procedure contract_rank4_rank1_rank0_for_complex64
        module procedure contract_rank4_rank1_rank1_for_complex64
        module procedure contract_rank4_rank1_rank2_for_complex64
        module procedure contract_rank4_rank1_rank3_for_complex64
        module procedure contract_rank4_rank1_rank4_for_complex64
        module procedure contract_rank4_rank1_rank5_for_complex64
        module procedure contract_rank4_rank2_rank0_for_complex64
        module procedure contract_rank4_rank2_rank1_for_complex64
        module procedure contract_rank4_rank2_rank2_for_complex64
        module procedure contract_rank4_rank2_rank3_for_complex64
        module procedure contract_rank4_rank2_rank4_for_complex64
        module procedure contract_rank4_rank2_rank5_for_complex64
        module procedure contract_rank4_rank3_rank0_for_complex64
        module procedure contract_rank4_rank3_rank1_for_complex64
        module procedure contract_rank4_rank3_rank2_for_complex64
        module procedure contract_rank4_rank3_rank3_for_complex64
        module procedure contract_rank4_rank3_rank4_for_complex64
        module procedure contract_rank4_rank3_rank5_for_complex64
        module procedure contract_rank4_rank4_rank0_for_complex64
        module procedure contract_rank4_rank4_rank1_for_complex64
        module procedure contract_rank4_rank4_rank2_for_complex64
        module procedure contract_rank4_rank4_rank3_for_complex64
        module procedure contract_rank4_rank4_rank4_for_complex64
        module procedure contract_rank4_rank4_rank5_for_complex64
        module procedure contract_rank4_rank5_rank0_for_complex64
        module procedure contract_rank4_rank5_rank1_for_complex64
        module procedure contract_rank4_rank5_rank2_for_complex64
        module procedure contract_rank4_rank5_rank3_for_complex64
        module procedure contract_rank4_rank5_rank4_for_complex64
        module procedure contract_rank4_rank5_rank5_for_complex64
        module procedure contract_rank5_rank0_rank0_for_complex64
        module procedure contract_rank5_rank0_rank1_for_complex64
        module procedure contract_rank5_rank0_rank2_for_complex64
        module procedure contract_rank5_rank0_rank3_for_complex64
        module procedure contract_rank5_rank0_rank4_for_complex64
        module procedure contract_rank5_rank0_rank5_for_complex64
        module procedure contract_rank5_rank1_rank0_for_complex64
        module procedure contract_rank5_rank1_rank1_for_complex64
        module procedure contract_rank5_rank1_rank2_for_complex64
        module procedure contract_rank5_rank1_rank3_for_complex64
        module procedure contract_rank5_rank1_rank4_for_complex64
        module procedure contract_rank5_rank1_rank5_for_complex64
        module procedure contract_rank5_rank2_rank0_for_complex64
        module procedure contract_rank5_rank2_rank1_for_complex64
        module procedure contract_rank5_rank2_rank2_for_complex64
        module procedure contract_rank5_rank2_rank3_for_complex64
        module procedure contract_rank5_rank2_rank4_for_complex64
        module procedure contract_rank5_rank2_rank5_for_complex64
        module procedure contract_rank5_rank3_rank0_for_complex64
        module procedure contract_rank5_rank3_rank1_for_complex64
        module procedure contract_rank5_rank3_rank2_for_complex64
        module procedure contract_rank5_rank3_rank3_for_complex64
        module procedure contract_rank5_rank3_rank4_for_complex64
        module procedure contract_rank5_rank3_rank5_for_complex64
        module procedure contract_rank5_rank4_rank0_for_complex64
        module procedure contract_rank5_rank4_rank1_for_complex64
        module procedure contract_rank5_rank4_rank2_for_complex64
        module procedure contract_rank5_rank4_rank3_for_complex64
        module procedure contract_rank5_rank4_rank4_for_complex64
        module procedure contract_rank5_rank4_rank5_for_complex64
        module procedure contract_rank5_rank5_rank0_for_complex64
        module procedure contract_rank5_rank5_rank1_for_complex64
        module procedure contract_rank5_rank5_rank2_for_complex64
        module procedure contract_rank5_rank5_rank3_for_complex64
        module procedure contract_rank5_rank5_rank4_for_complex64
        module procedure contract_rank5_rank5_rank5_for_complex64
        module procedure contract_rank0_rank0_rank0_for_real64
        module procedure contract_rank0_rank0_rank1_for_real64
        module procedure contract_rank0_rank0_rank2_for_real64
        module procedure contract_rank0_rank0_rank3_for_real64
        module procedure contract_rank0_rank0_rank4_for_real64
        module procedure contract_rank0_rank0_rank5_for_real64
        module procedure contract_rank0_rank1_rank0_for_real64
        module procedure contract_rank0_rank1_rank1_for_real64
        module procedure contract_rank0_rank1_rank2_for_real64
        module procedure contract_rank0_rank1_rank3_for_real64
        module procedure contract_rank0_rank1_rank4_for_real64
        module procedure contract_rank0_rank1_rank5_for_real64
        module procedure contract_rank0_rank2_rank0_for_real64
        module procedure contract_rank0_rank2_rank1_for_real64
        module procedure contract_rank0_rank2_rank2_for_real64
        module procedure contract_rank0_rank2_rank3_for_real64
        module procedure contract_rank0_rank2_rank4_for_real64
        module procedure contract_rank0_rank2_rank5_for_real64
        module procedure contract_rank0_rank3_rank0_for_real64
        module procedure contract_rank0_rank3_rank1_for_real64
        module procedure contract_rank0_rank3_rank2_for_real64
        module procedure contract_rank0_rank3_rank3_for_real64
        module procedure contract_rank0_rank3_rank4_for_real64
        module procedure contract_rank0_rank3_rank5_for_real64
        module procedure contract_rank0_rank4_rank0_for_real64
        module procedure contract_rank0_rank4_rank1_for_real64
        module procedure contract_rank0_rank4_rank2_for_real64
        module procedure contract_rank0_rank4_rank3_for_real64
        module procedure contract_rank0_rank4_rank4_for_real64
        module procedure contract_rank0_rank4_rank5_for_real64
        module procedure contract_rank0_rank5_rank0_for_real64
        module procedure contract_rank0_rank5_rank1_for_real64
        module procedure contract_rank0_rank5_rank2_for_real64
        module procedure contract_rank0_rank5_rank3_for_real64
        module procedure contract_rank0_rank5_rank4_for_real64
        module procedure contract_rank0_rank5_rank5_for_real64
        module procedure contract_rank1_rank0_rank0_for_real64
        module procedure contract_rank1_rank0_rank1_for_real64
        module procedure contract_rank1_rank0_rank2_for_real64
        module procedure contract_rank1_rank0_rank3_for_real64
        module procedure contract_rank1_rank0_rank4_for_real64
        module procedure contract_rank1_rank0_rank5_for_real64
        module procedure contract_rank1_rank1_rank0_for_real64
        module procedure contract_rank1_rank1_rank1_for_real64
        module procedure contract_rank1_rank1_rank2_for_real64
        module procedure contract_rank1_rank1_rank3_for_real64
        module procedure contract_rank1_rank1_rank4_for_real64
        module procedure contract_rank1_rank1_rank5_for_real64
        module procedure contract_rank1_rank2_rank0_for_real64
        module procedure contract_rank1_rank2_rank1_for_real64
        module procedure contract_rank1_rank2_rank2_for_real64
        module procedure contract_rank1_rank2_rank3_for_real64
        module procedure contract_rank1_rank2_rank4_for_real64
        module procedure contract_rank1_rank2_rank5_for_real64
        module procedure contract_rank1_rank3_rank0_for_real64
        module procedure contract_rank1_rank3_rank1_for_real64
        module procedure contract_rank1_rank3_rank2_for_real64
        module procedure contract_rank1_rank3_rank3_for_real64
        module procedure contract_rank1_rank3_rank4_for_real64
        module procedure contract_rank1_rank3_rank5_for_real64
        module procedure contract_rank1_rank4_rank0_for_real64
        module procedure contract_rank1_rank4_rank1_for_real64
        module procedure contract_rank1_rank4_rank2_for_real64
        module procedure contract_rank1_rank4_rank3_for_real64
        module procedure contract_rank1_rank4_rank4_for_real64
        module procedure contract_rank1_rank4_rank5_for_real64
        module procedure contract_rank1_rank5_rank0_for_real64
        module procedure contract_rank1_rank5_rank1_for_real64
        module procedure contract_rank1_rank5_rank2_for_real64
        module procedure contract_rank1_rank5_rank3_for_real64
        module procedure contract_rank1_rank5_rank4_for_real64
        module procedure contract_rank1_rank5_rank5_for_real64
        module procedure contract_rank2_rank0_rank0_for_real64
        module procedure contract_rank2_rank0_rank1_for_real64
        module procedure contract_rank2_rank0_rank2_for_real64
        module procedure contract_rank2_rank0_rank3_for_real64
        module procedure contract_rank2_rank0_rank4_for_real64
        module procedure contract_rank2_rank0_rank5_for_real64
        module procedure contract_rank2_rank1_rank0_for_real64
        module procedure contract_rank2_rank1_rank1_for_real64
        module procedure contract_rank2_rank1_rank2_for_real64
        module procedure contract_rank2_rank1_rank3_for_real64
        module procedure contract_rank2_rank1_rank4_for_real64
        module procedure contract_rank2_rank1_rank5_for_real64
        module procedure contract_rank2_rank2_rank0_for_real64
        module procedure contract_rank2_rank2_rank1_for_real64
        module procedure contract_rank2_rank2_rank2_for_real64
        module procedure contract_rank2_rank2_rank3_for_real64
        module procedure contract_rank2_rank2_rank4_for_real64
        module procedure contract_rank2_rank2_rank5_for_real64
        module procedure contract_rank2_rank3_rank0_for_real64
        module procedure contract_rank2_rank3_rank1_for_real64
        module procedure contract_rank2_rank3_rank2_for_real64
        module procedure contract_rank2_rank3_rank3_for_real64
        module procedure contract_rank2_rank3_rank4_for_real64
        module procedure contract_rank2_rank3_rank5_for_real64
        module procedure contract_rank2_rank4_rank0_for_real64
        module procedure contract_rank2_rank4_rank1_for_real64
        module procedure contract_rank2_rank4_rank2_for_real64
        module procedure contract_rank2_rank4_rank3_for_real64
        module procedure contract_rank2_rank4_rank4_for_real64
        module procedure contract_rank2_rank4_rank5_for_real64
        module procedure contract_rank2_rank5_rank0_for_real64
        module procedure contract_rank2_rank5_rank1_for_real64
        module procedure contract_rank2_rank5_rank2_for_real64
        module procedure contract_rank2_rank5_rank3_for_real64
        module procedure contract_rank2_rank5_rank4_for_real64
        module procedure contract_rank2_rank5_rank5_for_real64
        module procedure contract_rank3_rank0_rank0_for_real64
        module procedure contract_rank3_rank0_rank1_for_real64
        module procedure contract_rank3_rank0_rank2_for_real64
        module procedure contract_rank3_rank0_rank3_for_real64
        module procedure contract_rank3_rank0_rank4_for_real64
        module procedure contract_rank3_rank0_rank5_for_real64
        module procedure contract_rank3_rank1_rank0_for_real64
        module procedure contract_rank3_rank1_rank1_for_real64
        module procedure contract_rank3_rank1_rank2_for_real64
        module procedure contract_rank3_rank1_rank3_for_real64
        module procedure contract_rank3_rank1_rank4_for_real64
        module procedure contract_rank3_rank1_rank5_for_real64
        module procedure contract_rank3_rank2_rank0_for_real64
        module procedure contract_rank3_rank2_rank1_for_real64
        module procedure contract_rank3_rank2_rank2_for_real64
        module procedure contract_rank3_rank2_rank3_for_real64
        module procedure contract_rank3_rank2_rank4_for_real64
        module procedure contract_rank3_rank2_rank5_for_real64
        module procedure contract_rank3_rank3_rank0_for_real64
        module procedure contract_rank3_rank3_rank1_for_real64
        module procedure contract_rank3_rank3_rank2_for_real64
        module procedure contract_rank3_rank3_rank3_for_real64
        module procedure contract_rank3_rank3_rank4_for_real64
        module procedure contract_rank3_rank3_rank5_for_real64
        module procedure contract_rank3_rank4_rank0_for_real64
        module procedure contract_rank3_rank4_rank1_for_real64
        module procedure contract_rank3_rank4_rank2_for_real64
        module procedure contract_rank3_rank4_rank3_for_real64
        module procedure contract_rank3_rank4_rank4_for_real64
        module procedure contract_rank3_rank4_rank5_for_real64
        module procedure contract_rank3_rank5_rank0_for_real64
        module procedure contract_rank3_rank5_rank1_for_real64
        module procedure contract_rank3_rank5_rank2_for_real64
        module procedure contract_rank3_rank5_rank3_for_real64
        module procedure contract_rank3_rank5_rank4_for_real64
        module procedure contract_rank3_rank5_rank5_for_real64
        module procedure contract_rank4_rank0_rank0_for_real64
        module procedure contract_rank4_rank0_rank1_for_real64
        module procedure contract_rank4_rank0_rank2_for_real64
        module procedure contract_rank4_rank0_rank3_for_real64
        module procedure contract_rank4_rank0_rank4_for_real64
        module procedure contract_rank4_rank0_rank5_for_real64
        module procedure contract_rank4_rank1_rank0_for_real64
        module procedure contract_rank4_rank1_rank1_for_real64
        module procedure contract_rank4_rank1_rank2_for_real64
        module procedure contract_rank4_rank1_rank3_for_real64
        module procedure contract_rank4_rank1_rank4_for_real64
        module procedure contract_rank4_rank1_rank5_for_real64
        module procedure contract_rank4_rank2_rank0_for_real64
        module procedure contract_rank4_rank2_rank1_for_real64
        module procedure contract_rank4_rank2_rank2_for_real64
        module procedure contract_rank4_rank2_rank3_for_real64
        module procedure contract_rank4_rank2_rank4_for_real64
        module procedure contract_rank4_rank2_rank5_for_real64
        module procedure contract_rank4_rank3_rank0_for_real64
        module procedure contract_rank4_rank3_rank1_for_real64
        module procedure contract_rank4_rank3_rank2_for_real64
        module procedure contract_rank4_rank3_rank3_for_real64
        module procedure contract_rank4_rank3_rank4_for_real64
        module procedure contract_rank4_rank3_rank5_for_real64
        module procedure contract_rank4_rank4_rank0_for_real64
        module procedure contract_rank4_rank4_rank1_for_real64
        module procedure contract_rank4_rank4_rank2_for_real64
        module procedure contract_rank4_rank4_rank3_for_real64
        module procedure contract_rank4_rank4_rank4_for_real64
        module procedure contract_rank4_rank4_rank5_for_real64
        module procedure contract_rank4_rank5_rank0_for_real64
        module procedure contract_rank4_rank5_rank1_for_real64
        module procedure contract_rank4_rank5_rank2_for_real64
        module procedure contract_rank4_rank5_rank3_for_real64
        module procedure contract_rank4_rank5_rank4_for_real64
        module procedure contract_rank4_rank5_rank5_for_real64
        module procedure contract_rank5_rank0_rank0_for_real64
        module procedure contract_rank5_rank0_rank1_for_real64
        module procedure contract_rank5_rank0_rank2_for_real64
        module procedure contract_rank5_rank0_rank3_for_real64
        module procedure contract_rank5_rank0_rank4_for_real64
        module procedure contract_rank5_rank0_rank5_for_real64
        module procedure contract_rank5_rank1_rank0_for_real64
        module procedure contract_rank5_rank1_rank1_for_real64
        module procedure contract_rank5_rank1_rank2_for_real64
        module procedure contract_rank5_rank1_rank3_for_real64
        module procedure contract_rank5_rank1_rank4_for_real64
        module procedure contract_rank5_rank1_rank5_for_real64
        module procedure contract_rank5_rank2_rank0_for_real64
        module procedure contract_rank5_rank2_rank1_for_real64
        module procedure contract_rank5_rank2_rank2_for_real64
        module procedure contract_rank5_rank2_rank3_for_real64
        module procedure contract_rank5_rank2_rank4_for_real64
        module procedure contract_rank5_rank2_rank5_for_real64
        module procedure contract_rank5_rank3_rank0_for_real64
        module procedure contract_rank5_rank3_rank1_for_real64
        module procedure contract_rank5_rank3_rank2_for_real64
        module procedure contract_rank5_rank3_rank3_for_real64
        module procedure contract_rank5_rank3_rank4_for_real64
        module procedure contract_rank5_rank3_rank5_for_real64
        module procedure contract_rank5_rank4_rank0_for_real64
        module procedure contract_rank5_rank4_rank1_for_real64
        module procedure contract_rank5_rank4_rank2_for_real64
        module procedure contract_rank5_rank4_rank3_for_real64
        module procedure contract_rank5_rank4_rank4_for_real64
        module procedure contract_rank5_rank4_rank5_for_real64
        module procedure contract_rank5_rank5_rank0_for_real64
        module procedure contract_rank5_rank5_rank1_for_real64
        module procedure contract_rank5_rank5_rank2_for_real64
        module procedure contract_rank5_rank5_rank3_for_real64
        module procedure contract_rank5_rank5_rank4_for_real64
        module procedure contract_rank5_rank5_rank5_for_real64
        module procedure contract_rank0_rank0_rank0_for_real32
        module procedure contract_rank0_rank0_rank1_for_real32
        module procedure contract_rank0_rank0_rank2_for_real32
        module procedure contract_rank0_rank0_rank3_for_real32
        module procedure contract_rank0_rank0_rank4_for_real32
        module procedure contract_rank0_rank0_rank5_for_real32
        module procedure contract_rank0_rank1_rank0_for_real32
        module procedure contract_rank0_rank1_rank1_for_real32
        module procedure contract_rank0_rank1_rank2_for_real32
        module procedure contract_rank0_rank1_rank3_for_real32
        module procedure contract_rank0_rank1_rank4_for_real32
        module procedure contract_rank0_rank1_rank5_for_real32
        module procedure contract_rank0_rank2_rank0_for_real32
        module procedure contract_rank0_rank2_rank1_for_real32
        module procedure contract_rank0_rank2_rank2_for_real32
        module procedure contract_rank0_rank2_rank3_for_real32
        module procedure contract_rank0_rank2_rank4_for_real32
        module procedure contract_rank0_rank2_rank5_for_real32
        module procedure contract_rank0_rank3_rank0_for_real32
        module procedure contract_rank0_rank3_rank1_for_real32
        module procedure contract_rank0_rank3_rank2_for_real32
        module procedure contract_rank0_rank3_rank3_for_real32
        module procedure contract_rank0_rank3_rank4_for_real32
        module procedure contract_rank0_rank3_rank5_for_real32
        module procedure contract_rank0_rank4_rank0_for_real32
        module procedure contract_rank0_rank4_rank1_for_real32
        module procedure contract_rank0_rank4_rank2_for_real32
        module procedure contract_rank0_rank4_rank3_for_real32
        module procedure contract_rank0_rank4_rank4_for_real32
        module procedure contract_rank0_rank4_rank5_for_real32
        module procedure contract_rank0_rank5_rank0_for_real32
        module procedure contract_rank0_rank5_rank1_for_real32
        module procedure contract_rank0_rank5_rank2_for_real32
        module procedure contract_rank0_rank5_rank3_for_real32
        module procedure contract_rank0_rank5_rank4_for_real32
        module procedure contract_rank0_rank5_rank5_for_real32
        module procedure contract_rank1_rank0_rank0_for_real32
        module procedure contract_rank1_rank0_rank1_for_real32
        module procedure contract_rank1_rank0_rank2_for_real32
        module procedure contract_rank1_rank0_rank3_for_real32
        module procedure contract_rank1_rank0_rank4_for_real32
        module procedure contract_rank1_rank0_rank5_for_real32
        module procedure contract_rank1_rank1_rank0_for_real32
        module procedure contract_rank1_rank1_rank1_for_real32
        module procedure contract_rank1_rank1_rank2_for_real32
        module procedure contract_rank1_rank1_rank3_for_real32
        module procedure contract_rank1_rank1_rank4_for_real32
        module procedure contract_rank1_rank1_rank5_for_real32
        module procedure contract_rank1_rank2_rank0_for_real32
        module procedure contract_rank1_rank2_rank1_for_real32
        module procedure contract_rank1_rank2_rank2_for_real32
        module procedure contract_rank1_rank2_rank3_for_real32
        module procedure contract_rank1_rank2_rank4_for_real32
        module procedure contract_rank1_rank2_rank5_for_real32
        module procedure contract_rank1_rank3_rank0_for_real32
        module procedure contract_rank1_rank3_rank1_for_real32
        module procedure contract_rank1_rank3_rank2_for_real32
        module procedure contract_rank1_rank3_rank3_for_real32
        module procedure contract_rank1_rank3_rank4_for_real32
        module procedure contract_rank1_rank3_rank5_for_real32
        module procedure contract_rank1_rank4_rank0_for_real32
        module procedure contract_rank1_rank4_rank1_for_real32
        module procedure contract_rank1_rank4_rank2_for_real32
        module procedure contract_rank1_rank4_rank3_for_real32
        module procedure contract_rank1_rank4_rank4_for_real32
        module procedure contract_rank1_rank4_rank5_for_real32
        module procedure contract_rank1_rank5_rank0_for_real32
        module procedure contract_rank1_rank5_rank1_for_real32
        module procedure contract_rank1_rank5_rank2_for_real32
        module procedure contract_rank1_rank5_rank3_for_real32
        module procedure contract_rank1_rank5_rank4_for_real32
        module procedure contract_rank1_rank5_rank5_for_real32
        module procedure contract_rank2_rank0_rank0_for_real32
        module procedure contract_rank2_rank0_rank1_for_real32
        module procedure contract_rank2_rank0_rank2_for_real32
        module procedure contract_rank2_rank0_rank3_for_real32
        module procedure contract_rank2_rank0_rank4_for_real32
        module procedure contract_rank2_rank0_rank5_for_real32
        module procedure contract_rank2_rank1_rank0_for_real32
        module procedure contract_rank2_rank1_rank1_for_real32
        module procedure contract_rank2_rank1_rank2_for_real32
        module procedure contract_rank2_rank1_rank3_for_real32
        module procedure contract_rank2_rank1_rank4_for_real32
        module procedure contract_rank2_rank1_rank5_for_real32
        module procedure contract_rank2_rank2_rank0_for_real32
        module procedure contract_rank2_rank2_rank1_for_real32
        module procedure contract_rank2_rank2_rank2_for_real32
        module procedure contract_rank2_rank2_rank3_for_real32
        module procedure contract_rank2_rank2_rank4_for_real32
        module procedure contract_rank2_rank2_rank5_for_real32
        module procedure contract_rank2_rank3_rank0_for_real32
        module procedure contract_rank2_rank3_rank1_for_real32
        module procedure contract_rank2_rank3_rank2_for_real32
        module procedure contract_rank2_rank3_rank3_for_real32
        module procedure contract_rank2_rank3_rank4_for_real32
        module procedure contract_rank2_rank3_rank5_for_real32
        module procedure contract_rank2_rank4_rank0_for_real32
        module procedure contract_rank2_rank4_rank1_for_real32
        module procedure contract_rank2_rank4_rank2_for_real32
        module procedure contract_rank2_rank4_rank3_for_real32
        module procedure contract_rank2_rank4_rank4_for_real32
        module procedure contract_rank2_rank4_rank5_for_real32
        module procedure contract_rank2_rank5_rank0_for_real32
        module procedure contract_rank2_rank5_rank1_for_real32
        module procedure contract_rank2_rank5_rank2_for_real32
        module procedure contract_rank2_rank5_rank3_for_real32
        module procedure contract_rank2_rank5_rank4_for_real32
        module procedure contract_rank2_rank5_rank5_for_real32
        module procedure contract_rank3_rank0_rank0_for_real32
        module procedure contract_rank3_rank0_rank1_for_real32
        module procedure contract_rank3_rank0_rank2_for_real32
        module procedure contract_rank3_rank0_rank3_for_real32
        module procedure contract_rank3_rank0_rank4_for_real32
        module procedure contract_rank3_rank0_rank5_for_real32
        module procedure contract_rank3_rank1_rank0_for_real32
        module procedure contract_rank3_rank1_rank1_for_real32
        module procedure contract_rank3_rank1_rank2_for_real32
        module procedure contract_rank3_rank1_rank3_for_real32
        module procedure contract_rank3_rank1_rank4_for_real32
        module procedure contract_rank3_rank1_rank5_for_real32
        module procedure contract_rank3_rank2_rank0_for_real32
        module procedure contract_rank3_rank2_rank1_for_real32
        module procedure contract_rank3_rank2_rank2_for_real32
        module procedure contract_rank3_rank2_rank3_for_real32
        module procedure contract_rank3_rank2_rank4_for_real32
        module procedure contract_rank3_rank2_rank5_for_real32
        module procedure contract_rank3_rank3_rank0_for_real32
        module procedure contract_rank3_rank3_rank1_for_real32
        module procedure contract_rank3_rank3_rank2_for_real32
        module procedure contract_rank3_rank3_rank3_for_real32
        module procedure contract_rank3_rank3_rank4_for_real32
        module procedure contract_rank3_rank3_rank5_for_real32
        module procedure contract_rank3_rank4_rank0_for_real32
        module procedure contract_rank3_rank4_rank1_for_real32
        module procedure contract_rank3_rank4_rank2_for_real32
        module procedure contract_rank3_rank4_rank3_for_real32
        module procedure contract_rank3_rank4_rank4_for_real32
        module procedure contract_rank3_rank4_rank5_for_real32
        module procedure contract_rank3_rank5_rank0_for_real32
        module procedure contract_rank3_rank5_rank1_for_real32
        module procedure contract_rank3_rank5_rank2_for_real32
        module procedure contract_rank3_rank5_rank3_for_real32
        module procedure contract_rank3_rank5_rank4_for_real32
        module procedure contract_rank3_rank5_rank5_for_real32
        module procedure contract_rank4_rank0_rank0_for_real32
        module procedure contract_rank4_rank0_rank1_for_real32
        module procedure contract_rank4_rank0_rank2_for_real32
        module procedure contract_rank4_rank0_rank3_for_real32
        module procedure contract_rank4_rank0_rank4_for_real32
        module procedure contract_rank4_rank0_rank5_for_real32
        module procedure contract_rank4_rank1_rank0_for_real32
        module procedure contract_rank4_rank1_rank1_for_real32
        module procedure contract_rank4_rank1_rank2_for_real32
        module procedure contract_rank4_rank1_rank3_for_real32
        module procedure contract_rank4_rank1_rank4_for_real32
        module procedure contract_rank4_rank1_rank5_for_real32
        module procedure contract_rank4_rank2_rank0_for_real32
        module procedure contract_rank4_rank2_rank1_for_real32
        module procedure contract_rank4_rank2_rank2_for_real32
        module procedure contract_rank4_rank2_rank3_for_real32
        module procedure contract_rank4_rank2_rank4_for_real32
        module procedure contract_rank4_rank2_rank5_for_real32
        module procedure contract_rank4_rank3_rank0_for_real32
        module procedure contract_rank4_rank3_rank1_for_real32
        module procedure contract_rank4_rank3_rank2_for_real32
        module procedure contract_rank4_rank3_rank3_for_real32
        module procedure contract_rank4_rank3_rank4_for_real32
        module procedure contract_rank4_rank3_rank5_for_real32
        module procedure contract_rank4_rank4_rank0_for_real32
        module procedure contract_rank4_rank4_rank1_for_real32
        module procedure contract_rank4_rank4_rank2_for_real32
        module procedure contract_rank4_rank4_rank3_for_real32
        module procedure contract_rank4_rank4_rank4_for_real32
        module procedure contract_rank4_rank4_rank5_for_real32
        module procedure contract_rank4_rank5_rank0_for_real32
        module procedure contract_rank4_rank5_rank1_for_real32
        module procedure contract_rank4_rank5_rank2_for_real32
        module procedure contract_rank4_rank5_rank3_for_real32
        module procedure contract_rank4_rank5_rank4_for_real32
        module procedure contract_rank4_rank5_rank5_for_real32
        module procedure contract_rank5_rank0_rank0_for_real32
        module procedure contract_rank5_rank0_rank1_for_real32
        module procedure contract_rank5_rank0_rank2_for_real32
        module procedure contract_rank5_rank0_rank3_for_real32
        module procedure contract_rank5_rank0_rank4_for_real32
        module procedure contract_rank5_rank0_rank5_for_real32
        module procedure contract_rank5_rank1_rank0_for_real32
        module procedure contract_rank5_rank1_rank1_for_real32
        module procedure contract_rank5_rank1_rank2_for_real32
        module procedure contract_rank5_rank1_rank3_for_real32
        module procedure contract_rank5_rank1_rank4_for_real32
        module procedure contract_rank5_rank1_rank5_for_real32
        module procedure contract_rank5_rank2_rank0_for_real32
        module procedure contract_rank5_rank2_rank1_for_real32
        module procedure contract_rank5_rank2_rank2_for_real32
        module procedure contract_rank5_rank2_rank3_for_real32
        module procedure contract_rank5_rank2_rank4_for_real32
        module procedure contract_rank5_rank2_rank5_for_real32
        module procedure contract_rank5_rank3_rank0_for_real32
        module procedure contract_rank5_rank3_rank1_for_real32
        module procedure contract_rank5_rank3_rank2_for_real32
        module procedure contract_rank5_rank3_rank3_for_real32
        module procedure contract_rank5_rank3_rank4_for_real32
        module procedure contract_rank5_rank3_rank5_for_real32
        module procedure contract_rank5_rank4_rank0_for_real32
        module procedure contract_rank5_rank4_rank1_for_real32
        module procedure contract_rank5_rank4_rank2_for_real32
        module procedure contract_rank5_rank4_rank3_for_real32
        module procedure contract_rank5_rank4_rank4_for_real32
        module procedure contract_rank5_rank4_rank5_for_real32
        module procedure contract_rank5_rank5_rank0_for_real32
        module procedure contract_rank5_rank5_rank1_for_real32
        module procedure contract_rank5_rank5_rank2_for_real32
        module procedure contract_rank5_rank5_rank3_for_real32
        module procedure contract_rank5_rank5_rank4_for_real32
        module procedure contract_rank5_rank5_rank5_for_real32
    end interface contract
contains
    subroutine contract_rank0_rank0_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank0_for_complex128

    subroutine contract_rank0_rank0_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank1_for_complex128

    subroutine contract_rank0_rank0_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank2_for_complex128

    subroutine contract_rank0_rank0_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank3_for_complex128

    subroutine contract_rank0_rank0_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank4_for_complex128

    subroutine contract_rank0_rank0_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank5_for_complex128

    subroutine contract_rank0_rank1_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank0_for_complex128

    subroutine contract_rank0_rank1_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank1_for_complex128

    subroutine contract_rank0_rank1_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank2_for_complex128

    subroutine contract_rank0_rank1_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank3_for_complex128

    subroutine contract_rank0_rank1_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank4_for_complex128

    subroutine contract_rank0_rank1_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank5_for_complex128

    subroutine contract_rank0_rank2_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank0_for_complex128

    subroutine contract_rank0_rank2_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank1_for_complex128

    subroutine contract_rank0_rank2_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank2_for_complex128

    subroutine contract_rank0_rank2_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank3_for_complex128

    subroutine contract_rank0_rank2_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank4_for_complex128

    subroutine contract_rank0_rank2_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank5_for_complex128

    subroutine contract_rank0_rank3_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank0_for_complex128

    subroutine contract_rank0_rank3_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank1_for_complex128

    subroutine contract_rank0_rank3_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank2_for_complex128

    subroutine contract_rank0_rank3_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank3_for_complex128

    subroutine contract_rank0_rank3_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank4_for_complex128

    subroutine contract_rank0_rank3_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank5_for_complex128

    subroutine contract_rank0_rank4_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank0_for_complex128

    subroutine contract_rank0_rank4_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank1_for_complex128

    subroutine contract_rank0_rank4_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank2_for_complex128

    subroutine contract_rank0_rank4_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank3_for_complex128

    subroutine contract_rank0_rank4_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank4_for_complex128

    subroutine contract_rank0_rank4_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank5_for_complex128

    subroutine contract_rank0_rank5_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank0_for_complex128

    subroutine contract_rank0_rank5_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank1_for_complex128

    subroutine contract_rank0_rank5_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank2_for_complex128

    subroutine contract_rank0_rank5_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank3_for_complex128

    subroutine contract_rank0_rank5_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank4_for_complex128

    subroutine contract_rank0_rank5_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank5_for_complex128

    subroutine contract_rank1_rank0_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank0_for_complex128

    subroutine contract_rank1_rank0_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank1_for_complex128

    subroutine contract_rank1_rank0_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank2_for_complex128

    subroutine contract_rank1_rank0_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank3_for_complex128

    subroutine contract_rank1_rank0_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank4_for_complex128

    subroutine contract_rank1_rank0_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank5_for_complex128

    subroutine contract_rank1_rank1_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank0_for_complex128

    subroutine contract_rank1_rank1_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank1_for_complex128

    subroutine contract_rank1_rank1_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank2_for_complex128

    subroutine contract_rank1_rank1_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank3_for_complex128

    subroutine contract_rank1_rank1_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank4_for_complex128

    subroutine contract_rank1_rank1_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank5_for_complex128

    subroutine contract_rank1_rank2_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank0_for_complex128

    subroutine contract_rank1_rank2_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank1_for_complex128

    subroutine contract_rank1_rank2_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank2_for_complex128

    subroutine contract_rank1_rank2_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank3_for_complex128

    subroutine contract_rank1_rank2_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank4_for_complex128

    subroutine contract_rank1_rank2_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank5_for_complex128

    subroutine contract_rank1_rank3_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank0_for_complex128

    subroutine contract_rank1_rank3_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank1_for_complex128

    subroutine contract_rank1_rank3_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank2_for_complex128

    subroutine contract_rank1_rank3_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank3_for_complex128

    subroutine contract_rank1_rank3_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank4_for_complex128

    subroutine contract_rank1_rank3_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank5_for_complex128

    subroutine contract_rank1_rank4_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank0_for_complex128

    subroutine contract_rank1_rank4_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank1_for_complex128

    subroutine contract_rank1_rank4_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank2_for_complex128

    subroutine contract_rank1_rank4_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank3_for_complex128

    subroutine contract_rank1_rank4_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank4_for_complex128

    subroutine contract_rank1_rank4_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank5_for_complex128

    subroutine contract_rank1_rank5_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank0_for_complex128

    subroutine contract_rank1_rank5_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank1_for_complex128

    subroutine contract_rank1_rank5_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank2_for_complex128

    subroutine contract_rank1_rank5_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank3_for_complex128

    subroutine contract_rank1_rank5_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank4_for_complex128

    subroutine contract_rank1_rank5_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank5_for_complex128

    subroutine contract_rank2_rank0_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank0_for_complex128

    subroutine contract_rank2_rank0_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank1_for_complex128

    subroutine contract_rank2_rank0_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank2_for_complex128

    subroutine contract_rank2_rank0_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank3_for_complex128

    subroutine contract_rank2_rank0_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank4_for_complex128

    subroutine contract_rank2_rank0_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank5_for_complex128

    subroutine contract_rank2_rank1_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank0_for_complex128

    subroutine contract_rank2_rank1_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank1_for_complex128

    subroutine contract_rank2_rank1_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank2_for_complex128

    subroutine contract_rank2_rank1_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank3_for_complex128

    subroutine contract_rank2_rank1_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank4_for_complex128

    subroutine contract_rank2_rank1_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank5_for_complex128

    subroutine contract_rank2_rank2_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank0_for_complex128

    subroutine contract_rank2_rank2_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank1_for_complex128

    subroutine contract_rank2_rank2_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank2_for_complex128

    subroutine contract_rank2_rank2_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank3_for_complex128

    subroutine contract_rank2_rank2_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank4_for_complex128

    subroutine contract_rank2_rank2_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank5_for_complex128

    subroutine contract_rank2_rank3_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank0_for_complex128

    subroutine contract_rank2_rank3_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank1_for_complex128

    subroutine contract_rank2_rank3_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank2_for_complex128

    subroutine contract_rank2_rank3_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank3_for_complex128

    subroutine contract_rank2_rank3_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank4_for_complex128

    subroutine contract_rank2_rank3_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank5_for_complex128

    subroutine contract_rank2_rank4_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank0_for_complex128

    subroutine contract_rank2_rank4_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank1_for_complex128

    subroutine contract_rank2_rank4_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank2_for_complex128

    subroutine contract_rank2_rank4_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank3_for_complex128

    subroutine contract_rank2_rank4_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank4_for_complex128

    subroutine contract_rank2_rank4_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank5_for_complex128

    subroutine contract_rank2_rank5_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank0_for_complex128

    subroutine contract_rank2_rank5_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank1_for_complex128

    subroutine contract_rank2_rank5_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank2_for_complex128

    subroutine contract_rank2_rank5_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank3_for_complex128

    subroutine contract_rank2_rank5_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank4_for_complex128

    subroutine contract_rank2_rank5_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank5_for_complex128

    subroutine contract_rank3_rank0_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank0_for_complex128

    subroutine contract_rank3_rank0_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank1_for_complex128

    subroutine contract_rank3_rank0_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank2_for_complex128

    subroutine contract_rank3_rank0_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank3_for_complex128

    subroutine contract_rank3_rank0_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank4_for_complex128

    subroutine contract_rank3_rank0_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank5_for_complex128

    subroutine contract_rank3_rank1_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank0_for_complex128

    subroutine contract_rank3_rank1_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank1_for_complex128

    subroutine contract_rank3_rank1_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank2_for_complex128

    subroutine contract_rank3_rank1_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank3_for_complex128

    subroutine contract_rank3_rank1_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank4_for_complex128

    subroutine contract_rank3_rank1_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank5_for_complex128

    subroutine contract_rank3_rank2_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank0_for_complex128

    subroutine contract_rank3_rank2_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank1_for_complex128

    subroutine contract_rank3_rank2_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank2_for_complex128

    subroutine contract_rank3_rank2_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank3_for_complex128

    subroutine contract_rank3_rank2_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank4_for_complex128

    subroutine contract_rank3_rank2_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank5_for_complex128

    subroutine contract_rank3_rank3_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank0_for_complex128

    subroutine contract_rank3_rank3_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank1_for_complex128

    subroutine contract_rank3_rank3_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank2_for_complex128

    subroutine contract_rank3_rank3_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank3_for_complex128

    subroutine contract_rank3_rank3_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank4_for_complex128

    subroutine contract_rank3_rank3_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank5_for_complex128

    subroutine contract_rank3_rank4_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank0_for_complex128

    subroutine contract_rank3_rank4_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank1_for_complex128

    subroutine contract_rank3_rank4_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank2_for_complex128

    subroutine contract_rank3_rank4_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank3_for_complex128

    subroutine contract_rank3_rank4_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank4_for_complex128

    subroutine contract_rank3_rank4_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank5_for_complex128

    subroutine contract_rank3_rank5_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank0_for_complex128

    subroutine contract_rank3_rank5_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank1_for_complex128

    subroutine contract_rank3_rank5_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank2_for_complex128

    subroutine contract_rank3_rank5_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank3_for_complex128

    subroutine contract_rank3_rank5_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank4_for_complex128

    subroutine contract_rank3_rank5_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank5_for_complex128

    subroutine contract_rank4_rank0_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank0_for_complex128

    subroutine contract_rank4_rank0_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank1_for_complex128

    subroutine contract_rank4_rank0_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank2_for_complex128

    subroutine contract_rank4_rank0_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank3_for_complex128

    subroutine contract_rank4_rank0_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank4_for_complex128

    subroutine contract_rank4_rank0_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank5_for_complex128

    subroutine contract_rank4_rank1_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank0_for_complex128

    subroutine contract_rank4_rank1_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank1_for_complex128

    subroutine contract_rank4_rank1_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank2_for_complex128

    subroutine contract_rank4_rank1_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank3_for_complex128

    subroutine contract_rank4_rank1_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank4_for_complex128

    subroutine contract_rank4_rank1_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank5_for_complex128

    subroutine contract_rank4_rank2_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank0_for_complex128

    subroutine contract_rank4_rank2_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank1_for_complex128

    subroutine contract_rank4_rank2_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank2_for_complex128

    subroutine contract_rank4_rank2_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank3_for_complex128

    subroutine contract_rank4_rank2_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank4_for_complex128

    subroutine contract_rank4_rank2_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank5_for_complex128

    subroutine contract_rank4_rank3_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank0_for_complex128

    subroutine contract_rank4_rank3_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank1_for_complex128

    subroutine contract_rank4_rank3_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank2_for_complex128

    subroutine contract_rank4_rank3_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank3_for_complex128

    subroutine contract_rank4_rank3_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank4_for_complex128

    subroutine contract_rank4_rank3_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank5_for_complex128

    subroutine contract_rank4_rank4_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank0_for_complex128

    subroutine contract_rank4_rank4_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank1_for_complex128

    subroutine contract_rank4_rank4_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank2_for_complex128

    subroutine contract_rank4_rank4_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank3_for_complex128

    subroutine contract_rank4_rank4_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank4_for_complex128

    subroutine contract_rank4_rank4_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank5_for_complex128

    subroutine contract_rank4_rank5_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank0_for_complex128

    subroutine contract_rank4_rank5_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank1_for_complex128

    subroutine contract_rank4_rank5_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank2_for_complex128

    subroutine contract_rank4_rank5_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank3_for_complex128

    subroutine contract_rank4_rank5_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank4_for_complex128

    subroutine contract_rank4_rank5_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank5_for_complex128

    subroutine contract_rank5_rank0_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank0_for_complex128

    subroutine contract_rank5_rank0_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank1_for_complex128

    subroutine contract_rank5_rank0_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank2_for_complex128

    subroutine contract_rank5_rank0_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank3_for_complex128

    subroutine contract_rank5_rank0_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank4_for_complex128

    subroutine contract_rank5_rank0_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank5_for_complex128

    subroutine contract_rank5_rank1_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank0_for_complex128

    subroutine contract_rank5_rank1_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank1_for_complex128

    subroutine contract_rank5_rank1_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank2_for_complex128

    subroutine contract_rank5_rank1_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank3_for_complex128

    subroutine contract_rank5_rank1_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank4_for_complex128

    subroutine contract_rank5_rank1_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank5_for_complex128

    subroutine contract_rank5_rank2_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank0_for_complex128

    subroutine contract_rank5_rank2_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank1_for_complex128

    subroutine contract_rank5_rank2_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank2_for_complex128

    subroutine contract_rank5_rank2_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank3_for_complex128

    subroutine contract_rank5_rank2_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank4_for_complex128

    subroutine contract_rank5_rank2_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank5_for_complex128

    subroutine contract_rank5_rank3_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank0_for_complex128

    subroutine contract_rank5_rank3_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank1_for_complex128

    subroutine contract_rank5_rank3_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank2_for_complex128

    subroutine contract_rank5_rank3_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank3_for_complex128

    subroutine contract_rank5_rank3_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank4_for_complex128

    subroutine contract_rank5_rank3_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank5_for_complex128

    subroutine contract_rank5_rank4_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank0_for_complex128

    subroutine contract_rank5_rank4_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank1_for_complex128

    subroutine contract_rank5_rank4_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank2_for_complex128

    subroutine contract_rank5_rank4_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank3_for_complex128

    subroutine contract_rank5_rank4_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank4_for_complex128

    subroutine contract_rank5_rank4_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank5_for_complex128

    subroutine contract_rank5_rank5_rank0_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank0_for_complex128

    subroutine contract_rank5_rank5_rank1_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank1_for_complex128

    subroutine contract_rank5_rank5_rank2_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank2_for_complex128

    subroutine contract_rank5_rank5_rank3_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank3_for_complex128

    subroutine contract_rank5_rank5_rank4_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank4_for_complex128

    subroutine contract_rank5_rank5_rank5_for_complex128(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real64), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real64), intent(in), optional :: alpha
        complex(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank5_for_complex128

    subroutine contract_rank0_rank0_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank0_for_complex64

    subroutine contract_rank0_rank0_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank1_for_complex64

    subroutine contract_rank0_rank0_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank2_for_complex64

    subroutine contract_rank0_rank0_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank3_for_complex64

    subroutine contract_rank0_rank0_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank4_for_complex64

    subroutine contract_rank0_rank0_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank5_for_complex64

    subroutine contract_rank0_rank1_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank0_for_complex64

    subroutine contract_rank0_rank1_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank1_for_complex64

    subroutine contract_rank0_rank1_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank2_for_complex64

    subroutine contract_rank0_rank1_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank3_for_complex64

    subroutine contract_rank0_rank1_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank4_for_complex64

    subroutine contract_rank0_rank1_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank5_for_complex64

    subroutine contract_rank0_rank2_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank0_for_complex64

    subroutine contract_rank0_rank2_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank1_for_complex64

    subroutine contract_rank0_rank2_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank2_for_complex64

    subroutine contract_rank0_rank2_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank3_for_complex64

    subroutine contract_rank0_rank2_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank4_for_complex64

    subroutine contract_rank0_rank2_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank5_for_complex64

    subroutine contract_rank0_rank3_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank0_for_complex64

    subroutine contract_rank0_rank3_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank1_for_complex64

    subroutine contract_rank0_rank3_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank2_for_complex64

    subroutine contract_rank0_rank3_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank3_for_complex64

    subroutine contract_rank0_rank3_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank4_for_complex64

    subroutine contract_rank0_rank3_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank5_for_complex64

    subroutine contract_rank0_rank4_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank0_for_complex64

    subroutine contract_rank0_rank4_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank1_for_complex64

    subroutine contract_rank0_rank4_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank2_for_complex64

    subroutine contract_rank0_rank4_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank3_for_complex64

    subroutine contract_rank0_rank4_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank4_for_complex64

    subroutine contract_rank0_rank4_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank5_for_complex64

    subroutine contract_rank0_rank5_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank0_for_complex64

    subroutine contract_rank0_rank5_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank1_for_complex64

    subroutine contract_rank0_rank5_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank2_for_complex64

    subroutine contract_rank0_rank5_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank3_for_complex64

    subroutine contract_rank0_rank5_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank4_for_complex64

    subroutine contract_rank0_rank5_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank5_for_complex64

    subroutine contract_rank1_rank0_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank0_for_complex64

    subroutine contract_rank1_rank0_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank1_for_complex64

    subroutine contract_rank1_rank0_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank2_for_complex64

    subroutine contract_rank1_rank0_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank3_for_complex64

    subroutine contract_rank1_rank0_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank4_for_complex64

    subroutine contract_rank1_rank0_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank5_for_complex64

    subroutine contract_rank1_rank1_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank0_for_complex64

    subroutine contract_rank1_rank1_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank1_for_complex64

    subroutine contract_rank1_rank1_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank2_for_complex64

    subroutine contract_rank1_rank1_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank3_for_complex64

    subroutine contract_rank1_rank1_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank4_for_complex64

    subroutine contract_rank1_rank1_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank5_for_complex64

    subroutine contract_rank1_rank2_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank0_for_complex64

    subroutine contract_rank1_rank2_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank1_for_complex64

    subroutine contract_rank1_rank2_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank2_for_complex64

    subroutine contract_rank1_rank2_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank3_for_complex64

    subroutine contract_rank1_rank2_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank4_for_complex64

    subroutine contract_rank1_rank2_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank5_for_complex64

    subroutine contract_rank1_rank3_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank0_for_complex64

    subroutine contract_rank1_rank3_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank1_for_complex64

    subroutine contract_rank1_rank3_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank2_for_complex64

    subroutine contract_rank1_rank3_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank3_for_complex64

    subroutine contract_rank1_rank3_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank4_for_complex64

    subroutine contract_rank1_rank3_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank5_for_complex64

    subroutine contract_rank1_rank4_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank0_for_complex64

    subroutine contract_rank1_rank4_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank1_for_complex64

    subroutine contract_rank1_rank4_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank2_for_complex64

    subroutine contract_rank1_rank4_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank3_for_complex64

    subroutine contract_rank1_rank4_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank4_for_complex64

    subroutine contract_rank1_rank4_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank5_for_complex64

    subroutine contract_rank1_rank5_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank0_for_complex64

    subroutine contract_rank1_rank5_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank1_for_complex64

    subroutine contract_rank1_rank5_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank2_for_complex64

    subroutine contract_rank1_rank5_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank3_for_complex64

    subroutine contract_rank1_rank5_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank4_for_complex64

    subroutine contract_rank1_rank5_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank5_for_complex64

    subroutine contract_rank2_rank0_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank0_for_complex64

    subroutine contract_rank2_rank0_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank1_for_complex64

    subroutine contract_rank2_rank0_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank2_for_complex64

    subroutine contract_rank2_rank0_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank3_for_complex64

    subroutine contract_rank2_rank0_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank4_for_complex64

    subroutine contract_rank2_rank0_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank5_for_complex64

    subroutine contract_rank2_rank1_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank0_for_complex64

    subroutine contract_rank2_rank1_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank1_for_complex64

    subroutine contract_rank2_rank1_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank2_for_complex64

    subroutine contract_rank2_rank1_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank3_for_complex64

    subroutine contract_rank2_rank1_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank4_for_complex64

    subroutine contract_rank2_rank1_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank5_for_complex64

    subroutine contract_rank2_rank2_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank0_for_complex64

    subroutine contract_rank2_rank2_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank1_for_complex64

    subroutine contract_rank2_rank2_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank2_for_complex64

    subroutine contract_rank2_rank2_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank3_for_complex64

    subroutine contract_rank2_rank2_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank4_for_complex64

    subroutine contract_rank2_rank2_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank5_for_complex64

    subroutine contract_rank2_rank3_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank0_for_complex64

    subroutine contract_rank2_rank3_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank1_for_complex64

    subroutine contract_rank2_rank3_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank2_for_complex64

    subroutine contract_rank2_rank3_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank3_for_complex64

    subroutine contract_rank2_rank3_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank4_for_complex64

    subroutine contract_rank2_rank3_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank5_for_complex64

    subroutine contract_rank2_rank4_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank0_for_complex64

    subroutine contract_rank2_rank4_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank1_for_complex64

    subroutine contract_rank2_rank4_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank2_for_complex64

    subroutine contract_rank2_rank4_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank3_for_complex64

    subroutine contract_rank2_rank4_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank4_for_complex64

    subroutine contract_rank2_rank4_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank5_for_complex64

    subroutine contract_rank2_rank5_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank0_for_complex64

    subroutine contract_rank2_rank5_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank1_for_complex64

    subroutine contract_rank2_rank5_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank2_for_complex64

    subroutine contract_rank2_rank5_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank3_for_complex64

    subroutine contract_rank2_rank5_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank4_for_complex64

    subroutine contract_rank2_rank5_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank5_for_complex64

    subroutine contract_rank3_rank0_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank0_for_complex64

    subroutine contract_rank3_rank0_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank1_for_complex64

    subroutine contract_rank3_rank0_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank2_for_complex64

    subroutine contract_rank3_rank0_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank3_for_complex64

    subroutine contract_rank3_rank0_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank4_for_complex64

    subroutine contract_rank3_rank0_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank5_for_complex64

    subroutine contract_rank3_rank1_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank0_for_complex64

    subroutine contract_rank3_rank1_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank1_for_complex64

    subroutine contract_rank3_rank1_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank2_for_complex64

    subroutine contract_rank3_rank1_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank3_for_complex64

    subroutine contract_rank3_rank1_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank4_for_complex64

    subroutine contract_rank3_rank1_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank5_for_complex64

    subroutine contract_rank3_rank2_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank0_for_complex64

    subroutine contract_rank3_rank2_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank1_for_complex64

    subroutine contract_rank3_rank2_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank2_for_complex64

    subroutine contract_rank3_rank2_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank3_for_complex64

    subroutine contract_rank3_rank2_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank4_for_complex64

    subroutine contract_rank3_rank2_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank5_for_complex64

    subroutine contract_rank3_rank3_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank0_for_complex64

    subroutine contract_rank3_rank3_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank1_for_complex64

    subroutine contract_rank3_rank3_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank2_for_complex64

    subroutine contract_rank3_rank3_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank3_for_complex64

    subroutine contract_rank3_rank3_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank4_for_complex64

    subroutine contract_rank3_rank3_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank5_for_complex64

    subroutine contract_rank3_rank4_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank0_for_complex64

    subroutine contract_rank3_rank4_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank1_for_complex64

    subroutine contract_rank3_rank4_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank2_for_complex64

    subroutine contract_rank3_rank4_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank3_for_complex64

    subroutine contract_rank3_rank4_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank4_for_complex64

    subroutine contract_rank3_rank4_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank5_for_complex64

    subroutine contract_rank3_rank5_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank0_for_complex64

    subroutine contract_rank3_rank5_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank1_for_complex64

    subroutine contract_rank3_rank5_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank2_for_complex64

    subroutine contract_rank3_rank5_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank3_for_complex64

    subroutine contract_rank3_rank5_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank4_for_complex64

    subroutine contract_rank3_rank5_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank5_for_complex64

    subroutine contract_rank4_rank0_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank0_for_complex64

    subroutine contract_rank4_rank0_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank1_for_complex64

    subroutine contract_rank4_rank0_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank2_for_complex64

    subroutine contract_rank4_rank0_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank3_for_complex64

    subroutine contract_rank4_rank0_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank4_for_complex64

    subroutine contract_rank4_rank0_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank5_for_complex64

    subroutine contract_rank4_rank1_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank0_for_complex64

    subroutine contract_rank4_rank1_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank1_for_complex64

    subroutine contract_rank4_rank1_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank2_for_complex64

    subroutine contract_rank4_rank1_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank3_for_complex64

    subroutine contract_rank4_rank1_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank4_for_complex64

    subroutine contract_rank4_rank1_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank5_for_complex64

    subroutine contract_rank4_rank2_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank0_for_complex64

    subroutine contract_rank4_rank2_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank1_for_complex64

    subroutine contract_rank4_rank2_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank2_for_complex64

    subroutine contract_rank4_rank2_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank3_for_complex64

    subroutine contract_rank4_rank2_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank4_for_complex64

    subroutine contract_rank4_rank2_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank5_for_complex64

    subroutine contract_rank4_rank3_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank0_for_complex64

    subroutine contract_rank4_rank3_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank1_for_complex64

    subroutine contract_rank4_rank3_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank2_for_complex64

    subroutine contract_rank4_rank3_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank3_for_complex64

    subroutine contract_rank4_rank3_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank4_for_complex64

    subroutine contract_rank4_rank3_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank5_for_complex64

    subroutine contract_rank4_rank4_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank0_for_complex64

    subroutine contract_rank4_rank4_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank1_for_complex64

    subroutine contract_rank4_rank4_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank2_for_complex64

    subroutine contract_rank4_rank4_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank3_for_complex64

    subroutine contract_rank4_rank4_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank4_for_complex64

    subroutine contract_rank4_rank4_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank5_for_complex64

    subroutine contract_rank4_rank5_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank0_for_complex64

    subroutine contract_rank4_rank5_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank1_for_complex64

    subroutine contract_rank4_rank5_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank2_for_complex64

    subroutine contract_rank4_rank5_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank3_for_complex64

    subroutine contract_rank4_rank5_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank4_for_complex64

    subroutine contract_rank4_rank5_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank5_for_complex64

    subroutine contract_rank5_rank0_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank0_for_complex64

    subroutine contract_rank5_rank0_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank1_for_complex64

    subroutine contract_rank5_rank0_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank2_for_complex64

    subroutine contract_rank5_rank0_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank3_for_complex64

    subroutine contract_rank5_rank0_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank4_for_complex64

    subroutine contract_rank5_rank0_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank5_for_complex64

    subroutine contract_rank5_rank1_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank0_for_complex64

    subroutine contract_rank5_rank1_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank1_for_complex64

    subroutine contract_rank5_rank1_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank2_for_complex64

    subroutine contract_rank5_rank1_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank3_for_complex64

    subroutine contract_rank5_rank1_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank4_for_complex64

    subroutine contract_rank5_rank1_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank5_for_complex64

    subroutine contract_rank5_rank2_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank0_for_complex64

    subroutine contract_rank5_rank2_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank1_for_complex64

    subroutine contract_rank5_rank2_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank2_for_complex64

    subroutine contract_rank5_rank2_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank3_for_complex64

    subroutine contract_rank5_rank2_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank4_for_complex64

    subroutine contract_rank5_rank2_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank5_for_complex64

    subroutine contract_rank5_rank3_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank0_for_complex64

    subroutine contract_rank5_rank3_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank1_for_complex64

    subroutine contract_rank5_rank3_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank2_for_complex64

    subroutine contract_rank5_rank3_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank3_for_complex64

    subroutine contract_rank5_rank3_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank4_for_complex64

    subroutine contract_rank5_rank3_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank5_for_complex64

    subroutine contract_rank5_rank4_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank0_for_complex64

    subroutine contract_rank5_rank4_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank1_for_complex64

    subroutine contract_rank5_rank4_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank2_for_complex64

    subroutine contract_rank5_rank4_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank3_for_complex64

    subroutine contract_rank5_rank4_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank4_for_complex64

    subroutine contract_rank5_rank4_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank5_for_complex64

    subroutine contract_rank5_rank5_rank0_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank0_for_complex64

    subroutine contract_rank5_rank5_rank1_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank1_for_complex64

    subroutine contract_rank5_rank5_rank2_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank2_for_complex64

    subroutine contract_rank5_rank5_rank3_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank3_for_complex64

    subroutine contract_rank5_rank5_rank4_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank4_for_complex64

    subroutine contract_rank5_rank5_rank5_for_complex64(ca, aa, ba, contr, alpha, beta, options, priorities)
        complex(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        complex(real32), dimension(:,:,:,:,:), intent(in) :: aa
        complex(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        complex(real32), intent(in), optional :: alpha
        complex(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        complex(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank5_for_complex64

    subroutine contract_rank0_rank0_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank0_for_real64

    subroutine contract_rank0_rank0_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank1_for_real64

    subroutine contract_rank0_rank0_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank2_for_real64

    subroutine contract_rank0_rank0_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank3_for_real64

    subroutine contract_rank0_rank0_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank4_for_real64

    subroutine contract_rank0_rank0_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank5_for_real64

    subroutine contract_rank0_rank1_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank0_for_real64

    subroutine contract_rank0_rank1_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank1_for_real64

    subroutine contract_rank0_rank1_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank2_for_real64

    subroutine contract_rank0_rank1_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank3_for_real64

    subroutine contract_rank0_rank1_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank4_for_real64

    subroutine contract_rank0_rank1_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank5_for_real64

    subroutine contract_rank0_rank2_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank0_for_real64

    subroutine contract_rank0_rank2_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank1_for_real64

    subroutine contract_rank0_rank2_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank2_for_real64

    subroutine contract_rank0_rank2_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank3_for_real64

    subroutine contract_rank0_rank2_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank4_for_real64

    subroutine contract_rank0_rank2_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank5_for_real64

    subroutine contract_rank0_rank3_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank0_for_real64

    subroutine contract_rank0_rank3_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank1_for_real64

    subroutine contract_rank0_rank3_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank2_for_real64

    subroutine contract_rank0_rank3_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank3_for_real64

    subroutine contract_rank0_rank3_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank4_for_real64

    subroutine contract_rank0_rank3_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank5_for_real64

    subroutine contract_rank0_rank4_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank0_for_real64

    subroutine contract_rank0_rank4_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank1_for_real64

    subroutine contract_rank0_rank4_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank2_for_real64

    subroutine contract_rank0_rank4_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank3_for_real64

    subroutine contract_rank0_rank4_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank4_for_real64

    subroutine contract_rank0_rank4_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank5_for_real64

    subroutine contract_rank0_rank5_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank0_for_real64

    subroutine contract_rank0_rank5_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank1_for_real64

    subroutine contract_rank0_rank5_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank2_for_real64

    subroutine contract_rank0_rank5_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank3_for_real64

    subroutine contract_rank0_rank5_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank4_for_real64

    subroutine contract_rank0_rank5_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank5_for_real64

    subroutine contract_rank1_rank0_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank0_for_real64

    subroutine contract_rank1_rank0_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank1_for_real64

    subroutine contract_rank1_rank0_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank2_for_real64

    subroutine contract_rank1_rank0_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank3_for_real64

    subroutine contract_rank1_rank0_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank4_for_real64

    subroutine contract_rank1_rank0_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank5_for_real64

    subroutine contract_rank1_rank1_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank0_for_real64

    subroutine contract_rank1_rank1_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank1_for_real64

    subroutine contract_rank1_rank1_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank2_for_real64

    subroutine contract_rank1_rank1_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank3_for_real64

    subroutine contract_rank1_rank1_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank4_for_real64

    subroutine contract_rank1_rank1_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank5_for_real64

    subroutine contract_rank1_rank2_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank0_for_real64

    subroutine contract_rank1_rank2_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank1_for_real64

    subroutine contract_rank1_rank2_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank2_for_real64

    subroutine contract_rank1_rank2_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank3_for_real64

    subroutine contract_rank1_rank2_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank4_for_real64

    subroutine contract_rank1_rank2_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank5_for_real64

    subroutine contract_rank1_rank3_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank0_for_real64

    subroutine contract_rank1_rank3_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank1_for_real64

    subroutine contract_rank1_rank3_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank2_for_real64

    subroutine contract_rank1_rank3_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank3_for_real64

    subroutine contract_rank1_rank3_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank4_for_real64

    subroutine contract_rank1_rank3_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank5_for_real64

    subroutine contract_rank1_rank4_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank0_for_real64

    subroutine contract_rank1_rank4_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank1_for_real64

    subroutine contract_rank1_rank4_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank2_for_real64

    subroutine contract_rank1_rank4_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank3_for_real64

    subroutine contract_rank1_rank4_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank4_for_real64

    subroutine contract_rank1_rank4_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank5_for_real64

    subroutine contract_rank1_rank5_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank0_for_real64

    subroutine contract_rank1_rank5_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank1_for_real64

    subroutine contract_rank1_rank5_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank2_for_real64

    subroutine contract_rank1_rank5_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank3_for_real64

    subroutine contract_rank1_rank5_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank4_for_real64

    subroutine contract_rank1_rank5_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank5_for_real64

    subroutine contract_rank2_rank0_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank0_for_real64

    subroutine contract_rank2_rank0_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank1_for_real64

    subroutine contract_rank2_rank0_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank2_for_real64

    subroutine contract_rank2_rank0_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank3_for_real64

    subroutine contract_rank2_rank0_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank4_for_real64

    subroutine contract_rank2_rank0_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank5_for_real64

    subroutine contract_rank2_rank1_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank0_for_real64

    subroutine contract_rank2_rank1_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank1_for_real64

    subroutine contract_rank2_rank1_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank2_for_real64

    subroutine contract_rank2_rank1_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank3_for_real64

    subroutine contract_rank2_rank1_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank4_for_real64

    subroutine contract_rank2_rank1_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank5_for_real64

    subroutine contract_rank2_rank2_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank0_for_real64

    subroutine contract_rank2_rank2_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank1_for_real64

    subroutine contract_rank2_rank2_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank2_for_real64

    subroutine contract_rank2_rank2_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank3_for_real64

    subroutine contract_rank2_rank2_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank4_for_real64

    subroutine contract_rank2_rank2_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank5_for_real64

    subroutine contract_rank2_rank3_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank0_for_real64

    subroutine contract_rank2_rank3_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank1_for_real64

    subroutine contract_rank2_rank3_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank2_for_real64

    subroutine contract_rank2_rank3_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank3_for_real64

    subroutine contract_rank2_rank3_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank4_for_real64

    subroutine contract_rank2_rank3_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank5_for_real64

    subroutine contract_rank2_rank4_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank0_for_real64

    subroutine contract_rank2_rank4_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank1_for_real64

    subroutine contract_rank2_rank4_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank2_for_real64

    subroutine contract_rank2_rank4_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank3_for_real64

    subroutine contract_rank2_rank4_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank4_for_real64

    subroutine contract_rank2_rank4_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank5_for_real64

    subroutine contract_rank2_rank5_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank0_for_real64

    subroutine contract_rank2_rank5_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank1_for_real64

    subroutine contract_rank2_rank5_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank2_for_real64

    subroutine contract_rank2_rank5_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank3_for_real64

    subroutine contract_rank2_rank5_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank4_for_real64

    subroutine contract_rank2_rank5_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank5_for_real64

    subroutine contract_rank3_rank0_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank0_for_real64

    subroutine contract_rank3_rank0_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank1_for_real64

    subroutine contract_rank3_rank0_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank2_for_real64

    subroutine contract_rank3_rank0_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank3_for_real64

    subroutine contract_rank3_rank0_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank4_for_real64

    subroutine contract_rank3_rank0_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank5_for_real64

    subroutine contract_rank3_rank1_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank0_for_real64

    subroutine contract_rank3_rank1_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank1_for_real64

    subroutine contract_rank3_rank1_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank2_for_real64

    subroutine contract_rank3_rank1_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank3_for_real64

    subroutine contract_rank3_rank1_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank4_for_real64

    subroutine contract_rank3_rank1_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank5_for_real64

    subroutine contract_rank3_rank2_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank0_for_real64

    subroutine contract_rank3_rank2_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank1_for_real64

    subroutine contract_rank3_rank2_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank2_for_real64

    subroutine contract_rank3_rank2_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank3_for_real64

    subroutine contract_rank3_rank2_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank4_for_real64

    subroutine contract_rank3_rank2_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank5_for_real64

    subroutine contract_rank3_rank3_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank0_for_real64

    subroutine contract_rank3_rank3_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank1_for_real64

    subroutine contract_rank3_rank3_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank2_for_real64

    subroutine contract_rank3_rank3_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank3_for_real64

    subroutine contract_rank3_rank3_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank4_for_real64

    subroutine contract_rank3_rank3_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank5_for_real64

    subroutine contract_rank3_rank4_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank0_for_real64

    subroutine contract_rank3_rank4_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank1_for_real64

    subroutine contract_rank3_rank4_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank2_for_real64

    subroutine contract_rank3_rank4_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank3_for_real64

    subroutine contract_rank3_rank4_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank4_for_real64

    subroutine contract_rank3_rank4_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank5_for_real64

    subroutine contract_rank3_rank5_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank0_for_real64

    subroutine contract_rank3_rank5_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank1_for_real64

    subroutine contract_rank3_rank5_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank2_for_real64

    subroutine contract_rank3_rank5_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank3_for_real64

    subroutine contract_rank3_rank5_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank4_for_real64

    subroutine contract_rank3_rank5_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank5_for_real64

    subroutine contract_rank4_rank0_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank0_for_real64

    subroutine contract_rank4_rank0_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank1_for_real64

    subroutine contract_rank4_rank0_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank2_for_real64

    subroutine contract_rank4_rank0_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank3_for_real64

    subroutine contract_rank4_rank0_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank4_for_real64

    subroutine contract_rank4_rank0_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank5_for_real64

    subroutine contract_rank4_rank1_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank0_for_real64

    subroutine contract_rank4_rank1_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank1_for_real64

    subroutine contract_rank4_rank1_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank2_for_real64

    subroutine contract_rank4_rank1_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank3_for_real64

    subroutine contract_rank4_rank1_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank4_for_real64

    subroutine contract_rank4_rank1_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank5_for_real64

    subroutine contract_rank4_rank2_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank0_for_real64

    subroutine contract_rank4_rank2_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank1_for_real64

    subroutine contract_rank4_rank2_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank2_for_real64

    subroutine contract_rank4_rank2_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank3_for_real64

    subroutine contract_rank4_rank2_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank4_for_real64

    subroutine contract_rank4_rank2_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank5_for_real64

    subroutine contract_rank4_rank3_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank0_for_real64

    subroutine contract_rank4_rank3_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank1_for_real64

    subroutine contract_rank4_rank3_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank2_for_real64

    subroutine contract_rank4_rank3_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank3_for_real64

    subroutine contract_rank4_rank3_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank4_for_real64

    subroutine contract_rank4_rank3_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank5_for_real64

    subroutine contract_rank4_rank4_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank0_for_real64

    subroutine contract_rank4_rank4_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank1_for_real64

    subroutine contract_rank4_rank4_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank2_for_real64

    subroutine contract_rank4_rank4_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank3_for_real64

    subroutine contract_rank4_rank4_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank4_for_real64

    subroutine contract_rank4_rank4_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank5_for_real64

    subroutine contract_rank4_rank5_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank0_for_real64

    subroutine contract_rank4_rank5_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank1_for_real64

    subroutine contract_rank4_rank5_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank2_for_real64

    subroutine contract_rank4_rank5_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank3_for_real64

    subroutine contract_rank4_rank5_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank4_for_real64

    subroutine contract_rank4_rank5_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank5_for_real64

    subroutine contract_rank5_rank0_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank0_for_real64

    subroutine contract_rank5_rank0_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank1_for_real64

    subroutine contract_rank5_rank0_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank2_for_real64

    subroutine contract_rank5_rank0_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank3_for_real64

    subroutine contract_rank5_rank0_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank4_for_real64

    subroutine contract_rank5_rank0_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank5_for_real64

    subroutine contract_rank5_rank1_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank0_for_real64

    subroutine contract_rank5_rank1_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank1_for_real64

    subroutine contract_rank5_rank1_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank2_for_real64

    subroutine contract_rank5_rank1_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank3_for_real64

    subroutine contract_rank5_rank1_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank4_for_real64

    subroutine contract_rank5_rank1_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank5_for_real64

    subroutine contract_rank5_rank2_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank0_for_real64

    subroutine contract_rank5_rank2_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank1_for_real64

    subroutine contract_rank5_rank2_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank2_for_real64

    subroutine contract_rank5_rank2_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank3_for_real64

    subroutine contract_rank5_rank2_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank4_for_real64

    subroutine contract_rank5_rank2_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank5_for_real64

    subroutine contract_rank5_rank3_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank0_for_real64

    subroutine contract_rank5_rank3_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank1_for_real64

    subroutine contract_rank5_rank3_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank2_for_real64

    subroutine contract_rank5_rank3_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank3_for_real64

    subroutine contract_rank5_rank3_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank4_for_real64

    subroutine contract_rank5_rank3_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank5_for_real64

    subroutine contract_rank5_rank4_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank0_for_real64

    subroutine contract_rank5_rank4_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank1_for_real64

    subroutine contract_rank5_rank4_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank2_for_real64

    subroutine contract_rank5_rank4_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank3_for_real64

    subroutine contract_rank5_rank4_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank4_for_real64

    subroutine contract_rank5_rank4_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank5_for_real64

    subroutine contract_rank5_rank5_rank0_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank0_for_real64

    subroutine contract_rank5_rank5_rank1_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank1_for_real64

    subroutine contract_rank5_rank5_rank2_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank2_for_real64

    subroutine contract_rank5_rank5_rank3_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank3_for_real64

    subroutine contract_rank5_rank5_rank4_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank4_for_real64

    subroutine contract_rank5_rank5_rank5_for_real64(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real64), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real64), dimension(:,:,:,:,:), intent(in) :: aa
        real(real64), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real64), intent(in), optional :: alpha
        real(real64), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real64), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank5_for_real64

    subroutine contract_rank0_rank0_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank0_for_real32

    subroutine contract_rank0_rank0_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank1_for_real32

    subroutine contract_rank0_rank0_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank2_for_real32

    subroutine contract_rank0_rank0_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank3_for_real32

    subroutine contract_rank0_rank0_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank4_for_real32

    subroutine contract_rank0_rank0_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank0_rank5_for_real32

    subroutine contract_rank0_rank1_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank0_for_real32

    subroutine contract_rank0_rank1_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank1_for_real32

    subroutine contract_rank0_rank1_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank2_for_real32

    subroutine contract_rank0_rank1_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank3_for_real32

    subroutine contract_rank0_rank1_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank4_for_real32

    subroutine contract_rank0_rank1_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank1_rank5_for_real32

    subroutine contract_rank0_rank2_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank0_for_real32

    subroutine contract_rank0_rank2_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank1_for_real32

    subroutine contract_rank0_rank2_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank2_for_real32

    subroutine contract_rank0_rank2_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank3_for_real32

    subroutine contract_rank0_rank2_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank4_for_real32

    subroutine contract_rank0_rank2_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank2_rank5_for_real32

    subroutine contract_rank0_rank3_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank0_for_real32

    subroutine contract_rank0_rank3_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank1_for_real32

    subroutine contract_rank0_rank3_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank2_for_real32

    subroutine contract_rank0_rank3_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank3_for_real32

    subroutine contract_rank0_rank3_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank4_for_real32

    subroutine contract_rank0_rank3_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank3_rank5_for_real32

    subroutine contract_rank0_rank4_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank0_for_real32

    subroutine contract_rank0_rank4_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank1_for_real32

    subroutine contract_rank0_rank4_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank2_for_real32

    subroutine contract_rank0_rank4_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank3_for_real32

    subroutine contract_rank0_rank4_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank4_for_real32

    subroutine contract_rank0_rank4_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank4_rank5_for_real32

    subroutine contract_rank0_rank5_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank0_for_real32

    subroutine contract_rank0_rank5_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank1_for_real32

    subroutine contract_rank0_rank5_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank2_for_real32

    subroutine contract_rank0_rank5_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank3_for_real32

    subroutine contract_rank0_rank5_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank4_for_real32

    subroutine contract_rank0_rank5_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), pointer :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank0_rank5_rank5_for_real32

    subroutine contract_rank1_rank0_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank0_for_real32

    subroutine contract_rank1_rank0_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank1_for_real32

    subroutine contract_rank1_rank0_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank2_for_real32

    subroutine contract_rank1_rank0_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank3_for_real32

    subroutine contract_rank1_rank0_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank4_for_real32

    subroutine contract_rank1_rank0_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank0_rank5_for_real32

    subroutine contract_rank1_rank1_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank0_for_real32

    subroutine contract_rank1_rank1_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank1_for_real32

    subroutine contract_rank1_rank1_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank2_for_real32

    subroutine contract_rank1_rank1_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank3_for_real32

    subroutine contract_rank1_rank1_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank4_for_real32

    subroutine contract_rank1_rank1_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank1_rank5_for_real32

    subroutine contract_rank1_rank2_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank0_for_real32

    subroutine contract_rank1_rank2_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank1_for_real32

    subroutine contract_rank1_rank2_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank2_for_real32

    subroutine contract_rank1_rank2_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank3_for_real32

    subroutine contract_rank1_rank2_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank4_for_real32

    subroutine contract_rank1_rank2_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank2_rank5_for_real32

    subroutine contract_rank1_rank3_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank0_for_real32

    subroutine contract_rank1_rank3_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank1_for_real32

    subroutine contract_rank1_rank3_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank2_for_real32

    subroutine contract_rank1_rank3_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank3_for_real32

    subroutine contract_rank1_rank3_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank4_for_real32

    subroutine contract_rank1_rank3_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank3_rank5_for_real32

    subroutine contract_rank1_rank4_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank0_for_real32

    subroutine contract_rank1_rank4_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank1_for_real32

    subroutine contract_rank1_rank4_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank2_for_real32

    subroutine contract_rank1_rank4_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank3_for_real32

    subroutine contract_rank1_rank4_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank4_for_real32

    subroutine contract_rank1_rank4_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank4_rank5_for_real32

    subroutine contract_rank1_rank5_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank0_for_real32

    subroutine contract_rank1_rank5_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank1_for_real32

    subroutine contract_rank1_rank5_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank2_for_real32

    subroutine contract_rank1_rank5_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank3_for_real32

    subroutine contract_rank1_rank5_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank4_for_real32

    subroutine contract_rank1_rank5_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank1_rank5_rank5_for_real32

    subroutine contract_rank2_rank0_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank0_for_real32

    subroutine contract_rank2_rank0_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank1_for_real32

    subroutine contract_rank2_rank0_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank2_for_real32

    subroutine contract_rank2_rank0_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank3_for_real32

    subroutine contract_rank2_rank0_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank4_for_real32

    subroutine contract_rank2_rank0_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank0_rank5_for_real32

    subroutine contract_rank2_rank1_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank0_for_real32

    subroutine contract_rank2_rank1_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank1_for_real32

    subroutine contract_rank2_rank1_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank2_for_real32

    subroutine contract_rank2_rank1_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank3_for_real32

    subroutine contract_rank2_rank1_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank4_for_real32

    subroutine contract_rank2_rank1_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank1_rank5_for_real32

    subroutine contract_rank2_rank2_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank0_for_real32

    subroutine contract_rank2_rank2_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank1_for_real32

    subroutine contract_rank2_rank2_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank2_for_real32

    subroutine contract_rank2_rank2_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank3_for_real32

    subroutine contract_rank2_rank2_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank4_for_real32

    subroutine contract_rank2_rank2_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank2_rank5_for_real32

    subroutine contract_rank2_rank3_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank0_for_real32

    subroutine contract_rank2_rank3_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank1_for_real32

    subroutine contract_rank2_rank3_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank2_for_real32

    subroutine contract_rank2_rank3_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank3_for_real32

    subroutine contract_rank2_rank3_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank4_for_real32

    subroutine contract_rank2_rank3_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank3_rank5_for_real32

    subroutine contract_rank2_rank4_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank0_for_real32

    subroutine contract_rank2_rank4_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank1_for_real32

    subroutine contract_rank2_rank4_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank2_for_real32

    subroutine contract_rank2_rank4_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank3_for_real32

    subroutine contract_rank2_rank4_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank4_for_real32

    subroutine contract_rank2_rank4_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank4_rank5_for_real32

    subroutine contract_rank2_rank5_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank0_for_real32

    subroutine contract_rank2_rank5_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank1_for_real32

    subroutine contract_rank2_rank5_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank2_for_real32

    subroutine contract_rank2_rank5_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank3_for_real32

    subroutine contract_rank2_rank5_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank4_for_real32

    subroutine contract_rank2_rank5_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank2_rank5_rank5_for_real32

    subroutine contract_rank3_rank0_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank0_for_real32

    subroutine contract_rank3_rank0_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank1_for_real32

    subroutine contract_rank3_rank0_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank2_for_real32

    subroutine contract_rank3_rank0_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank3_for_real32

    subroutine contract_rank3_rank0_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank4_for_real32

    subroutine contract_rank3_rank0_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank0_rank5_for_real32

    subroutine contract_rank3_rank1_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank0_for_real32

    subroutine contract_rank3_rank1_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank1_for_real32

    subroutine contract_rank3_rank1_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank2_for_real32

    subroutine contract_rank3_rank1_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank3_for_real32

    subroutine contract_rank3_rank1_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank4_for_real32

    subroutine contract_rank3_rank1_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank1_rank5_for_real32

    subroutine contract_rank3_rank2_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank0_for_real32

    subroutine contract_rank3_rank2_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank1_for_real32

    subroutine contract_rank3_rank2_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank2_for_real32

    subroutine contract_rank3_rank2_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank3_for_real32

    subroutine contract_rank3_rank2_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank4_for_real32

    subroutine contract_rank3_rank2_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank2_rank5_for_real32

    subroutine contract_rank3_rank3_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank0_for_real32

    subroutine contract_rank3_rank3_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank1_for_real32

    subroutine contract_rank3_rank3_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank2_for_real32

    subroutine contract_rank3_rank3_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank3_for_real32

    subroutine contract_rank3_rank3_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank4_for_real32

    subroutine contract_rank3_rank3_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank3_rank5_for_real32

    subroutine contract_rank3_rank4_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank0_for_real32

    subroutine contract_rank3_rank4_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank1_for_real32

    subroutine contract_rank3_rank4_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank2_for_real32

    subroutine contract_rank3_rank4_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank3_for_real32

    subroutine contract_rank3_rank4_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank4_for_real32

    subroutine contract_rank3_rank4_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank4_rank5_for_real32

    subroutine contract_rank3_rank5_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank0_for_real32

    subroutine contract_rank3_rank5_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank1_for_real32

    subroutine contract_rank3_rank5_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank2_for_real32

    subroutine contract_rank3_rank5_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank3_for_real32

    subroutine contract_rank3_rank5_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank4_for_real32

    subroutine contract_rank3_rank5_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank3_rank5_rank5_for_real32

    subroutine contract_rank4_rank0_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank0_for_real32

    subroutine contract_rank4_rank0_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank1_for_real32

    subroutine contract_rank4_rank0_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank2_for_real32

    subroutine contract_rank4_rank0_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank3_for_real32

    subroutine contract_rank4_rank0_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank4_for_real32

    subroutine contract_rank4_rank0_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank0_rank5_for_real32

    subroutine contract_rank4_rank1_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank0_for_real32

    subroutine contract_rank4_rank1_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank1_for_real32

    subroutine contract_rank4_rank1_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank2_for_real32

    subroutine contract_rank4_rank1_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank3_for_real32

    subroutine contract_rank4_rank1_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank4_for_real32

    subroutine contract_rank4_rank1_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank1_rank5_for_real32

    subroutine contract_rank4_rank2_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank0_for_real32

    subroutine contract_rank4_rank2_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank1_for_real32

    subroutine contract_rank4_rank2_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank2_for_real32

    subroutine contract_rank4_rank2_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank3_for_real32

    subroutine contract_rank4_rank2_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank4_for_real32

    subroutine contract_rank4_rank2_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank2_rank5_for_real32

    subroutine contract_rank4_rank3_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank0_for_real32

    subroutine contract_rank4_rank3_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank1_for_real32

    subroutine contract_rank4_rank3_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank2_for_real32

    subroutine contract_rank4_rank3_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank3_for_real32

    subroutine contract_rank4_rank3_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank4_for_real32

    subroutine contract_rank4_rank3_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank3_rank5_for_real32

    subroutine contract_rank4_rank4_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank0_for_real32

    subroutine contract_rank4_rank4_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank1_for_real32

    subroutine contract_rank4_rank4_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank2_for_real32

    subroutine contract_rank4_rank4_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank3_for_real32

    subroutine contract_rank4_rank4_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank4_for_real32

    subroutine contract_rank4_rank4_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank4_rank5_for_real32

    subroutine contract_rank4_rank5_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank0_for_real32

    subroutine contract_rank4_rank5_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank1_for_real32

    subroutine contract_rank4_rank5_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank2_for_real32

    subroutine contract_rank4_rank5_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank3_for_real32

    subroutine contract_rank4_rank5_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank4_for_real32

    subroutine contract_rank4_rank5_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank4_rank5_rank5_for_real32

    subroutine contract_rank5_rank0_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank0_for_real32

    subroutine contract_rank5_rank0_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank1_for_real32

    subroutine contract_rank5_rank0_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank2_for_real32

    subroutine contract_rank5_rank0_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank3_for_real32

    subroutine contract_rank5_rank0_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank4_for_real32

    subroutine contract_rank5_rank0_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank0_rank5_for_real32

    subroutine contract_rank5_rank1_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank0_for_real32

    subroutine contract_rank5_rank1_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank1_for_real32

    subroutine contract_rank5_rank1_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank2_for_real32

    subroutine contract_rank5_rank1_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank3_for_real32

    subroutine contract_rank5_rank1_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank4_for_real32

    subroutine contract_rank5_rank1_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank1_rank5_for_real32

    subroutine contract_rank5_rank2_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank0_for_real32

    subroutine contract_rank5_rank2_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank1_for_real32

    subroutine contract_rank5_rank2_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank2_for_real32

    subroutine contract_rank5_rank2_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank3_for_real32

    subroutine contract_rank5_rank2_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank4_for_real32

    subroutine contract_rank5_rank2_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank2_rank5_for_real32

    subroutine contract_rank5_rank3_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank0_for_real32

    subroutine contract_rank5_rank3_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank1_for_real32

    subroutine contract_rank5_rank3_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank2_for_real32

    subroutine contract_rank5_rank3_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank3_for_real32

    subroutine contract_rank5_rank3_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank4_for_real32

    subroutine contract_rank5_rank3_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank3_rank5_for_real32

    subroutine contract_rank5_rank4_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank0_for_real32

    subroutine contract_rank5_rank4_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank1_for_real32

    subroutine contract_rank5_rank4_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank2_for_real32

    subroutine contract_rank5_rank4_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank3_for_real32

    subroutine contract_rank5_rank4_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank4_for_real32

    subroutine contract_rank5_rank4_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank4_rank5_for_real32

    subroutine contract_rank5_rank5_rank0_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank0_for_real32

    subroutine contract_rank5_rank5_rank1_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank1_for_real32

    subroutine contract_rank5_rank5_rank2_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank2_for_real32

    subroutine contract_rank5_rank5_rank3_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank3_for_real32

    subroutine contract_rank5_rank5_rank4_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank4_for_real32

    subroutine contract_rank5_rank5_rank5_for_real32(ca, aa, ba, contr, alpha, beta, options, priorities)
        real(real32), dimension(:,:,:,:,:), intent(inout) :: ca
        real(real32), dimension(:,:,:,:,:), intent(in) :: aa
        real(real32), dimension(:,:,:,:,:), intent(in) :: ba
        character(len=*), intent(in) :: contr
        real(real32), intent(in), optional :: alpha
        real(real32), intent(in), optional :: beta
        type(dictionary), intent(in), optional :: options
        type(string), dimension(:), intent(in), optional :: priorities

        class(tensor), allocatable :: c, a, b
        class(tensor_contraction), allocatable :: tc
        type(scalar) :: salpha, sbeta
        real(real32), dimension(:,:,:,:,:), pointer, contiguous :: cptr

        salpha=scalar(1)
        sbeta = scalar(0)
        if ( present(alpha) ) salpha = scalar(alpha)
        if ( present(beta) ) sbeta = scalar(beta)

        call allocate_and_copy_tensor(c, ca, options=options, priorities=priorities)
        call allocate_and_copy_tensor(a, aa, options=options, priorities=priorities)
        call allocate_and_copy_tensor(b, ba, options=options, priorities=priorities)

        call tensor_contraction_factory%create(tc, contr, options=options, priorities=priorities)

        call tc%contract(c, a, b, salpha, sbeta)
        call tc%synchronize()

        call secure_fortran_pointer_from_tensor(cptr, c)
        ca = cptr
        call release_pointer_from_remote_tensor(cptr, c)

        call c%cleanup()
        call a%cleanup()
        call b%cleanup()
        call tc%cleanup()
    end subroutine contract_rank5_rank5_rank5_for_real32
end module easy_tensor_contraction_interface
